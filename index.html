<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplified 3D Card Prototype</title>
    <style>
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            display: grid;
            grid-template-columns: 300px minmax(0, 1fr);
            grid-template-areas: "sidebar content";
            overflow: hidden;
        }

        .app-sidebar {
            grid-area: sidebar;
            height: 100vh;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow-y: auto;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .app-content {
            grid-area: content;
            height: 100vh;
            background-color: #ffffff;
            overflow: visible;
        }

        .content-scroll-wrapper {
            height: 100%;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .card-title {
            font-size: 20px;
            color: #6C6C6C;
            margin-top: 60px;
            font-weight: 100;
        }

        .image-container {
            text-align: center;
            max-width: 270px;
            max-height: 500px;
            position: relative;
            transform-style: preserve-3d;
            perspective: 1000px;
            perspective-origin: 50% 50%;
            overflow: visible;
        }

        .duplicate-image {
            position: absolute;
            border-radius: 32px;
            top: 0;
            left: 0;
            width: 270px;
            height: 400px;
            transform: rotateX(var(--rot-x, 0deg)) rotateY(var(--rot-y, 0deg)) translateZ(-5px) scale(var(--scale, 1)) translate(var(--tx, 0px), var(--ty, 0px));
            transform-origin: 50% 50%;
            filter: blur(var(--blur, 24px));
            opacity: var(--opacity, 0.6);
            transition: transform 0.3s ease-out, filter 0.3s ease-out, opacity 0.3s ease-out;
            backface-visibility: hidden;
        }

        .centered-image {
            border-radius: 32px;
            position: relative;
            width: 270px;
            height: 400px;
            transform: rotateX(var(--rot-x, 0deg)) rotateY(var(--rot-y, 0deg)) translateZ(0px);
            transform-origin: 50% 50%;
            transform-style: preserve-3d;
            transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
            backface-visibility: hidden;
            box-shadow: 
                var(--shadow-x-1, 0px) var(--shadow-y-1, 6px) 8px rgba(0,0,0,0.04),
                var(--shadow-x-2, 0px) var(--shadow-y-2, 18px) 24px rgba(0,0,0,0.08),
                var(--shadow-x-3, 0px) var(--shadow-y-3, 36px) 48px rgba(0,0,0,0.16);
        }

        .image-wrapper {
            width: 270px;
            height: 400px;
            margin: 0;
            padding: 0;
            line-height: 0;
            display: block;
            position: relative;
            transform-style: preserve-3d;
            overflow: visible;
        }

        .transform-container {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transform: rotateX(var(--rot-x, 0deg)) rotateY(var(--rot-y, 0deg));
            transition: transform 0.3s ease-out;
            backface-visibility: hidden;
            overflow: visible;
        }

        .image-container.mouse-leave .duplicate-image,
        .image-container.mouse-leave .centered-image {
            transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.6s ease-out, box-shadow 0.6s ease-out;
        }

        .control-group {
            margin-bottom: 15px;
            margin-top: 15px;
        }
        
        .control-group:first-of-type {
            margin-top: 10px;
        }

        .control-group .heading {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .control-group .heading span {
            font-weight: 500;
            color: #666;
        }

        .app-sidebar h4 {
            padding-top: 24px;
            margin: 0;
        }
        
        .app-sidebar > h4:first-child {
            padding-top: 0;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FF5A5F;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .control-group.disabled {
            display: none;
            pointer-events: none;
        }

        .control-group.checkbox {
            border-top: rgba(255, 255, 255, 0.95) solid 1px;
            padding-top: 16px;
            margin: 16px 0px;
        }

    </style>
</head>
<body>

    <div class="app-sidebar">
        <h4>Image</h4>
        <div class="control-group">
            <input type="file" id="imageUpload" accept="image/png,image/jpeg" style="width: 100%; margin-bottom: 8px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
            <button id="resetImage" style="width: 100%; padding: 6px 12px; background: #FF5A5F; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset to Gradient</button>
            <div id="uploadStatus" style="margin-top: 8px; font-size: 11px; color: #666;"></div>
        </div>

        <h4>Card</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="motionToggle" checked> 
                Interactive
            </label>
        </div>

        <div class="control-group rotation-control">
            <div class="heading">
                <label for="rotationX">X Rotation</label>
                <span><span id="rotationXValue">4</span>°</span>
            </div>
            <input type="range" id="rotationX" min="0" max="45" value="4" step="1">
        </div>
        
        <div class="control-group rotation-control">
            <div class="heading">
                <label for="rotationY">Y Rotation</label>
                <span><span id="rotationYValue">4</span>°</span>
            </div>
            <input type="range" id="rotationY" min="0" max="45" value="4" step="1">
        </div>

        <h4>Duplicate</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="duplicateVisible" checked> 
                Visible
            </label>
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateScale">Scale</label>
                <span><span id="duplicateScaleValue">100</span>%</span>
            </div>
            <input type="range" id="duplicateScale" min="50" max="100" value="100" step="1">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateOpacity">Opacity</label>
                <span><span id="duplicateOpacityValue">70</span>%</span>
            </div>
            <input type="range" id="duplicateOpacity" min="0" max="100" value="70" step="1">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateYOffset">Y Offset</label>
                <span><span id="duplicateYOffsetValue">18</span>px</span>
            </div>
            <input type="range" id="duplicateYOffset" min="0" max="64" value="18" step="1">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateBlur">Blur</label>
                <span><span id="duplicateBlurValue">24</span>px</span>
            </div>
            <input type="range" id="duplicateBlur" min="0" max="48" value="24" step="1">
        </div>

        <h4>Grain</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="grainToggle" checked> 
                Visible
            </label>
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainScale">Grain Scale</label>
                <span><span id="grainScaleValue">0.03</span></span>
            </div>
            <input type="range" id="grainScale" min="0.01" max="0.1" value="0.03" step="0.005">
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainIntensity">Grain Intensity</label>
                <span><span id="grainIntensityValue">1</span></span>
            </div>
            <input type="range" id="grainIntensity" min="0.0" max="3.0" value="1" step="0.1">
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainBias">Grain Bias</label>
                <span><span id="grainBiasValue">0</span></span>
            </div>
            <input type="range" id="grainBias" min="-1.0" max="1.0" value="0" step="0.1">
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainOpacity">Grain Opacity</label>
                <span><span id="grainOpacityValue">0.3</span></span>
            </div>
            <input type="range" id="grainOpacity" min="0.0" max="1.0" value="0.3" step="0.05">
        </div>

        <h4>Effects</h4>

        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="svgShadowsToggle" checked> 
                Shadows
            </label>
        </div>
    </div>

    <div class="app-content">
        <div class="content-scroll-wrapper">
            <div class="cards-wrapper" id="cardsWrapper">
            <div class="image-container" data-card="1">
                <div class="image-wrapper">
                    <canvas id="grainCanvas" class="grain-shadow" width="1480" height="1620" 
                            style="position: absolute; width: 740px; height: 810px; 
                                   top: -285px; left: -235px; pointer-events: none;
                                   transform-origin: 50% 50%;
                                   transition: transform 0.3s ease-out;
                                   backface-visibility: hidden;
                                   display: block;"></canvas>
                    <div class="duplicate-image" style="background: url('./assets/sofa.jpg'), linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%); background-size: cover; background-position: center; background-repeat: no-repeat;"></div>
                    <div class="centered-image" style="background: url('./assets/sofa.jpg'), linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%); background-size: cover; background-position: center; background-repeat: no-repeat;">
                    </div>
                </div>                 
            </div>
        </div>
        </div>
    </div>

<script>
class GrainShadowRenderer {
    constructor(canvas, settings) {
        this.canvas = canvas;
        this.settings = settings;
        this.debugMode = false; // Disable debug mode to test shadows
        this.gl = canvas.getContext('webgl', {
            alpha: true,
            premultipliedAlpha: false
        });
        
        if (!this.gl) {
            throw new Error('WebGL not supported');
        }
        
        this.program = this.createShaderProgram();
        this.setupGeometry();
        this.setupUniforms();
        
        this.shadowOffsets = {
            offset1: [0, 6],
            offset2: [0, 18],
            offset3: [0, 36]
        };
        
        this.render();
    }
    
    createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }
        
        return shader;
    }
    
    createShaderProgram() {
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            
            void main() {
                v_uv = (a_position + 1.0) * 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
        
        const fragmentShaderSource = `
            precision mediump float;
            
            uniform vec2 u_resolution;
            uniform vec2 u_shadowOffset1;
            uniform vec2 u_shadowOffset2;
            uniform vec2 u_shadowOffset3;
            uniform float u_grainScale;
            uniform float u_grainIntensity;
            uniform float u_grainBias;
            uniform float u_grainOpacity;
            uniform bool u_debugMode;
            
            varying vec2 v_uv;
            
            // Hash function for noise
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            
            // 2D hash
            vec2 hash2(vec2 p) {
                return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);
            }
            
            // Simplex noise
            float simplexNoise(vec2 p) {
                const float K1 = 0.366025404;
                const float K2 = 0.211324865;
                
                vec2 i = floor(p + (p.x + p.y) * K1);
                vec2 a = p - i + (i.x + i.y) * K2;
                float m = step(a.y, a.x);
                vec2 o = vec2(m, 1.0 - m);
                vec2 b = a - o + K2;
                vec2 c = a - 1.0 + 2.0 * K2;
                
                vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
                vec3 n = h * h * h * h * vec3(
                    dot(a, hash2(i) * 2.0 - 1.0),
                    dot(b, hash2(i + o) * 2.0 - 1.0),
                    dot(c, hash2(i + 1.0) * 2.0 - 1.0)
                );
                
                return dot(n, vec3(70.0)) * 0.5 + 0.5;
            }
            
            // Rounded rectangle SDF
            float roundedRectSDF(vec2 pos, vec2 size, float radius) {
                return length(max(abs(pos) - size + radius, 0.0)) - radius;
            }
            
            // Drop shadow with grain
            float dropShadow(vec2 fragCoord, vec2 center, vec2 size, float radius, vec2 offset, float blur, float opacity) {
                vec2 shadowCenter = center + offset;
                vec2 localPos = fragCoord - shadowCenter;
                float dist = roundedRectSDF(localPos, size * 0.5, radius);
                
                float shadow = 1.0 - smoothstep(-blur, blur, dist);
                return shadow * opacity;
            }
            
            void main() {
                // Flip Y coordinate to match CSS coordinate system (top-left origin)
                vec2 uv_flipped = vec2(v_uv.x, 1.0 - v_uv.y);
                vec2 fragCoord = uv_flipped * vec2(740.0, 810.0);
                
                // Debug mode: render test pattern
                if (u_debugMode) {
                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Solid red background
                    return;
                }
                
                // Card parameters - center positioned within large canvas  
                vec2 rectSize = vec2(270.0, 400.0); // Card size in CSS pixels
                float cornerRadius = 32.0; // Corner radius in CSS pixels  
                vec2 center = vec2(370.0, 485.0); // Card center: (235 + 135, 285 + 200) in canvas space
                
                // Single grainy shadow matching middle shadow (shadow-2) specifications
                float shadow = dropShadow(fragCoord, center, rectSize, cornerRadius, u_shadowOffset2, 24.0, u_grainOpacity);
                
                // Apply grain effect with overlay blending
                if (shadow > 0.0) {
                    vec2 noiseCoord = fragCoord / 100.0;
                    float frequency = 1.0 / u_grainScale;
                    float noiseValue = simplexNoise(noiseCoord * frequency);
                    
                    // Apply bias
                    noiseValue += u_grainBias * 0.3;
                    
                    // Create overlay blend: if noise < 0.5, darken; if > 0.5, lighten
                    float overlayGrain;
                    if (noiseValue < 0.5) {
                        // Darken: 2 * base * overlay
                        overlayGrain = 2.0 * shadow * noiseValue;
                    } else {
                        // Lighten: 1 - 2 * (1 - base) * (1 - overlay)
                        overlayGrain = 1.0 - 2.0 * (1.0 - shadow) * (1.0 - noiseValue);
                    }
                    
                    // Mix original shadow with overlay grain based on intensity
                    shadow = mix(shadow, overlayGrain, u_grainIntensity * 0.3);
                    shadow = clamp(shadow, 0.0, 1.0);
                }
                
                // Output black shadow with transparency
                gl_FragColor = vec4(0.0, 0.0, 0.0, shadow);
            }
        `;
        
        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        const program = this.gl.createProgram();
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);
        
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            console.error('Program linking error:', this.gl.getProgramInfoLog(program));
            return null;
        }
        
        return program;
    }
    
    setupGeometry() {
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        
        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
        
        this.positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
    }
    
    setupUniforms() {
        this.uniforms = {
            resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
            shadowOffset1: this.gl.getUniformLocation(this.program, 'u_shadowOffset1'),
            shadowOffset2: this.gl.getUniformLocation(this.program, 'u_shadowOffset2'),
            shadowOffset3: this.gl.getUniformLocation(this.program, 'u_shadowOffset3'),
            grainScale: this.gl.getUniformLocation(this.program, 'u_grainScale'),
            grainIntensity: this.gl.getUniformLocation(this.program, 'u_grainIntensity'),
            grainBias: this.gl.getUniformLocation(this.program, 'u_grainBias'),
            grainOpacity: this.gl.getUniformLocation(this.program, 'u_grainOpacity'),
            debugMode: this.gl.getUniformLocation(this.program, 'u_debugMode')
        };
    }
    
    updateShadowOffsets(offsets) {
        this.shadowOffsets = offsets;
        this.render();
    }
    
    updateGrainSettings(settings) {
        this.settings = settings;
        this.render();
    }
    
    setDebugMode(enabled) {
        this.debugMode = enabled;
        this.render();
    }
    
    render() {
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        
        // Enable overlay blending for natural grain effect
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA); // Standard alpha for now
        // Note: True overlay requires fragment shader implementation
        
        this.gl.useProgram(this.program);
        
        // Set uniforms
        this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
        this.gl.uniform2f(this.uniforms.shadowOffset1, this.shadowOffsets.offset1[0], this.shadowOffsets.offset1[1]);
        this.gl.uniform2f(this.uniforms.shadowOffset2, this.shadowOffsets.offset2[0], this.shadowOffsets.offset2[1]);
        this.gl.uniform2f(this.uniforms.shadowOffset3, this.shadowOffsets.offset3[0], this.shadowOffsets.offset3[1]);
        this.gl.uniform1f(this.uniforms.grainScale, this.settings.grainScale);
        this.gl.uniform1f(this.uniforms.grainIntensity, this.settings.grainIntensity);
        this.gl.uniform1f(this.uniforms.grainBias, this.settings.grainBias);
        this.gl.uniform1f(this.uniforms.grainOpacity, this.settings.grainOpacity);
        this.gl.uniform1i(this.uniforms.debugMode, this.debugMode ? 1 : 0);
        
        // Check for WebGL errors
        const error = this.gl.getError();
        if (error !== this.gl.NO_ERROR) {
            console.error('WebGL error after setting uniforms:', error);
        }
        
        // Draw
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(this.positionLocation);
        this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);
        
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
}

class ImageUploadHandler {
    constructor(cardSystem) {
        this.cardSystem = cardSystem;
        this.defaultGradient = 'linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%)';
        this.currentImageUrl = null;
        this.maxSize = 5 * 1024 * 1024; // 5MB  
        this.maxDimension = 2000; // Balanced for performance and quality
        this.statusElement = document.getElementById('uploadStatus');
    }
    
    validateFile(file) {
        // Type validation
        if (!['image/png', 'image/jpeg'].includes(file.type)) {
            throw new Error('Only PNG and JPEG files allowed');
        }
        // Size validation  
        if (file.size > this.maxSize) {
            throw new Error('File too large (max 5MB)');
        }
        return true;
    }
    
    async processUpload(file) {
        try {
            this.validateFile(file);
            this.setStatus('Processing image...', 'info');
            
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Dimension validation
                        if (img.width > this.maxDimension || img.height > this.maxDimension) {
                            reject(new Error(`Image too large (max ${this.maxDimension}×${this.maxDimension}px)`));
                            return;
                        }
                        
                        // Clean previous image
                        if (this.currentImageUrl && this.currentImageUrl.startsWith('data:')) {
                            // Don't revoke data URLs, just clear reference
                            this.currentImageUrl = null;
                        }
                        
                        this.currentImageUrl = e.target.result;
                        this.applyImageBackground();
                        this.setStatus(`Image uploaded (${img.width}×${img.height})`, 'success');
                        resolve();
                    };
                    img.onerror = () => reject(new Error('Invalid image file'));
                    img.src = e.target.result;
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        } catch (error) {
            this.setStatus(error.message, 'error');
            throw error;
        }
    }
    
    applyImageBackground() {
        if (!this.currentImageUrl) {
            console.error('No image URL available to apply');
            return;
        }
        
        const bgStyle = `url(${this.currentImageUrl})`;
        
        // Apply to main card and duplicate only (exclude shadow emulator)
        if (this.cardSystem.mainImage) {
            this.cardSystem.mainImage.style.background = bgStyle;
        } else {
            console.error('Main image element not found');
        }
        
        if (this.cardSystem.duplicateImage) {
            this.cardSystem.duplicateImage.style.background = bgStyle;
        } else {
            console.error('Duplicate image element not found');
        }
        
        // Ensure cover/no-repeat styling
        [this.cardSystem.mainImage, this.cardSystem.duplicateImage].filter(Boolean).forEach(el => {
            el.style.backgroundSize = 'cover';
            el.style.backgroundRepeat = 'no-repeat';
            el.style.backgroundPosition = 'center';
        });
    }
    
    resetToGradient() {
        if (this.currentImageUrl) {
            this.currentImageUrl = null;
        }
        
        // Restore gradient to main and duplicate cards
        [this.cardSystem.mainImage, this.cardSystem.duplicateImage].filter(Boolean).forEach(el => {
            el.style.background = this.defaultGradient;
            el.style.backgroundSize = '';
            el.style.backgroundRepeat = '';
            el.style.backgroundPosition = '';
        });
        
        this.setStatus('Reset to gradient', 'info');
        
        // Clear file input
        const fileInput = document.getElementById('imageUpload');
        if (fileInput) {
            fileInput.value = '';
        }
    }
    
    setStatus(message, type = 'info') {
        if (this.statusElement) {
            this.statusElement.textContent = message;
            this.statusElement.style.color = type === 'error' ? '#ff4444' : type === 'success' ? '#00aa00' : '#666';
        }
    }
}


class SimpleCardSystem {
    constructor() {
        this.settings = {
            motionEnabled: true,
            shadowsEnabled: true,
            grainEnabled: true,
            grainScale: 0.03,
            grainIntensity: 1,
            grainBias: 0,
            grainOpacity: 0.3,
            duplicateVisible: true,
            duplicateScale: 100,
            duplicateOpacity: 70,
            duplicateYOffset: 18,
            duplicateBlur: 24,
            maxTiltX: 4,
            maxTiltY: 4
        };
        
        this.container = document.querySelector('.image-container');
        this.mainImage = this.container.querySelector('.centered-image');
        this.duplicateImage = this.container.querySelector('.duplicate-image');
        this.grainCanvas = null;
        this.grainRenderer = null;
        this.maxDuplicateOffset = 15;
        this.imageUploadHandler = null;
        
        // Cache for shadow values to prevent redundant DOM updates
        this.lastShadowX = 0;
        this.lastShadowY = 0;
        
        this.init();
    }
    
    init() {
        this.initializeGrainCanvas();
        this.initializeControls();
        this.initializeImageUpload();
        this.attachEventListeners();
        this.toggleShadows(this.settings.shadowsEnabled);
        this.toggleGrain(this.settings.grainEnabled);
    }
    
    initializeGrainCanvas() {
        this.grainCanvas = document.getElementById('grainCanvas');
        
        if (this.grainCanvas) {
            try {
                this.grainRenderer = new GrainShadowRenderer(this.grainCanvas, this.settings);
                // Set static grain canvas transform once (safe distance for 4° tilt - 30px safety margin)
                this.grainCanvas.style.transform = 'translateZ(-30px)';
            } catch (e) {
                console.warn('WebGL not available for grain shadows:', e);
                this.settings.grainEnabled = false;
                this.grainCanvas.style.display = 'none';
            }
        }
    }
    
    initializeImageUpload() {
        this.imageUploadHandler = new ImageUploadHandler(this);
        
        // File input event listener
        const fileInput = document.getElementById('imageUpload');
        if (fileInput) {
            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        await this.imageUploadHandler.processUpload(file);
                    } catch (error) {
                        console.error('Image upload failed:', error);
                    }
                }
            });
        } else {
            console.error('File input not found');
        }
        
        // Reset button event listener
        const resetButton = document.getElementById('resetImage');
        if (resetButton) {
            resetButton.addEventListener('click', () => {
                this.imageUploadHandler.resetToGradient();
            });
        } else {
            console.error('Reset button not found');
        }
    }
    
    attachEventListeners() {
        document.addEventListener('pointermove', (e) => {
            if (!this.settings.motionEnabled) return;
            this.handleMouseMove(e);
        }, { passive: true });
        
        document.addEventListener('pointerleave', () => {
            this.handleMouseLeave();
        }, { passive: true });
    }
    
    handleMouseMove(event) {
        const bounds = this.container.getBoundingClientRect();
        const centerX = bounds.left + bounds.width / 2;
        const centerY = bounds.top + bounds.height / 2;
        
        const mouseX = event.clientX - centerX;
        const mouseY = event.clientY - centerY;
        
        const extendedZoneX = bounds.width * 0.75;
        const extendedZoneY = bounds.height * 0.75;
        
        const normalizedX = Math.max(-1.3, Math.min(1.3, mouseX / extendedZoneX));
        const normalizedY = Math.max(-1.3, Math.min(1.3, mouseY / extendedZoneY));
        
        const rotX = -normalizedY * this.settings.maxTiltX;
        const rotY = normalizedX * this.settings.maxTiltY;
        const translateX = -normalizedX * this.maxDuplicateOffset;
        const translateY = -normalizedY * this.maxDuplicateOffset;
        
        // Calculate dynamic opacity
        const distance = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
        const baseOpacity = this.settings.duplicateOpacity / 100;
        const opacityFactor = 1 - (Math.min(distance, 1.5) * 0.2);
        const opacity = Math.max(0.1, baseOpacity * opacityFactor);
        
        this.applyTransforms(rotX, rotY, translateX, translateY, opacity);
        
        this.container.classList.remove('mouse-leave');
    }
    
    applyTransforms(rotX, rotY, translateX, translateY, opacity) {
        // Standardized transform function order: rotateX() rotateY() translateZ() [scale()] [translate()]
        
        const baseTransform = `rotateX(${rotX.toFixed(1)}deg) rotateY(${rotY.toFixed(1)}deg)`;
        
        // Main card layer (reference point)
        this.mainImage.style.transform = `${baseTransform} translateZ(0px)`;
        
        // Duplicate layer (only if visible)
        if (this.settings.duplicateVisible) {
            const duplicateTransform = `${baseTransform} translateZ(-5px) scale(${(this.settings.duplicateScale / 100).toFixed(3)}) translate(${translateX.toFixed(1)}px, ${(this.settings.duplicateYOffset + translateY).toFixed(1)}px)`;
            this.duplicateImage.style.transform = duplicateTransform;
            this.duplicateImage.style.opacity = opacity.toFixed(3);
            this.duplicateImage.style.filter = `blur(${this.settings.duplicateBlur}px)`;
        }
        
        if (this.settings.shadowsEnabled) {
            this.updateBoxShadows(translateX, translateY);
        }
    }
    
    updateBoxShadows(translateX, translateY) {
        // Only update if shadow values have changed significantly (avoid micro-updates)
        if (Math.abs(translateX - this.lastShadowX) < 0.1 && Math.abs(translateY - this.lastShadowY) < 0.1) {
            return;
        }
        
        this.mainImage.style.setProperty('--shadow-x-1', `${(translateX * 0.3).toFixed(2)}px`);
        this.mainImage.style.setProperty('--shadow-y-1', `${(6 + translateY * 0.3).toFixed(2)}px`);
        
        this.mainImage.style.setProperty('--shadow-x-2', `${(translateX * 0.6).toFixed(2)}px`);
        this.mainImage.style.setProperty('--shadow-y-2', `${(18 + translateY * 0.6).toFixed(2)}px`);
        
        this.mainImage.style.setProperty('--shadow-x-3', `${translateX.toFixed(2)}px`);
        this.mainImage.style.setProperty('--shadow-y-3', `${(36 + translateY).toFixed(2)}px`);
        
        // Update grain renderer if available
        if (this.grainRenderer && this.settings.grainEnabled) {
            this.grainRenderer.updateShadowOffsets({
                offset1: [translateX * 0.3, 6 + translateY * 0.3],
                offset2: [translateX * 0.6, 18 + translateY * 0.6],
                offset3: [translateX, 36 + translateY]
            });
        }
        
        // Cache current values
        this.lastShadowX = translateX;
        this.lastShadowY = translateY;
    }
    
    handleMouseLeave() {
        this.container.classList.add('mouse-leave');
        this.resetToNeutral();
    }
    
    resetToNeutral() {
        const scale = this.settings.duplicateScale / 100;
        const opacity = this.settings.duplicateOpacity / 100;
        
        // Reset all transforms using manual rotation settings (not 0°)
        const neutralBaseTransform = `rotateX(${this.settings.maxTiltX}deg) rotateY(${this.settings.maxTiltY}deg)`;
        
        // All layers reset to neutral using manual rotation values
        
        // Main card reset
        this.mainImage.style.transform = `${neutralBaseTransform} translateZ(0px)`;
        
        const neutralDuplicateTransform = `${neutralBaseTransform} translateZ(-5px) scale(${scale.toFixed(3)}) translate(0px, ${this.settings.duplicateYOffset}px)`;
        this.duplicateImage.style.transform = neutralDuplicateTransform;
        this.duplicateImage.style.opacity = opacity.toFixed(3);
        this.duplicateImage.style.filter = `blur(${this.settings.duplicateBlur}px)`;
        
        this.resetBoxShadows();
    }
    
    
    resetBoxShadows() {
        this.mainImage.style.setProperty('--shadow-x-1', '0px');
        this.mainImage.style.setProperty('--shadow-y-1', '6px');
        
        this.mainImage.style.setProperty('--shadow-x-2', '0px');
        this.mainImage.style.setProperty('--shadow-y-2', '18px');
        
        this.mainImage.style.setProperty('--shadow-x-3', '0px');
        this.mainImage.style.setProperty('--shadow-y-3', '36px');
        
        // Reset main shadows only
        if (this.settings.shadowsEnabled) {
            this.mainImage.style.boxShadow = `
                var(--shadow-x-1, 0px) var(--shadow-y-1, 6px) 8px rgba(0,0,0,0.04),
                var(--shadow-x-2, 0px) var(--shadow-y-2, 18px) 24px rgba(0,0,0,0.08),
                var(--shadow-x-3, 0px) var(--shadow-y-3, 36px) 48px rgba(0,0,0,0.16)`;
        }
    }
    
    
    toggleShadows(enabled) {
        this.settings.shadowsEnabled = enabled;
        
        if (enabled) {
            // Enable box-shadow on main card
            this.mainImage.style.boxShadow = `
                var(--shadow-x-1, 0px) var(--shadow-y-1, 6px) 8px rgba(0,0,0,0.04),
                var(--shadow-x-2, 0px) var(--shadow-y-2, 18px) 24px rgba(0,0,0,0.08),
                var(--shadow-x-3, 0px) var(--shadow-y-3, 36px) 48px rgba(0,0,0,0.16)`;
        } else {
            // Disable shadows
            this.mainImage.style.boxShadow = 'none';
        }
        
        if (!enabled) {
            this.resetBoxShadows();
        }
    }
    
    toggleGrain(enabled) {
        this.settings.grainEnabled = enabled;
        
        if (this.grainCanvas && this.grainRenderer) {
            if (enabled) {
                this.grainCanvas.style.display = 'block';
                this.grainRenderer.render();
            } else {
                this.grainCanvas.style.display = 'none';
            }
        }
    }
    
    setGrainDebugMode(enabled) {
        if (this.grainRenderer) {
            this.grainRenderer.setDebugMode(enabled);
        }
    }
    
    toggleDuplicateControls(enabled) {
        const duplicateControls = ['duplicateScale', 'duplicateOpacity', 'duplicateYOffset', 'duplicateBlur'];
        duplicateControls.forEach(controlId => {
            const control = document.getElementById(controlId);
            const label = control?.closest('.control-group');
            if (label) {
                label.style.opacity = enabled ? '1' : '0.5';
                control.disabled = !enabled;
            }
        });
    }
    
    updateDuplicateVisibility() {
        if (this.duplicateImage) {
            this.duplicateImage.style.display = this.settings.duplicateVisible ? 'block' : 'none';
        }
    }
    
    toggleRotationControls(enabled) {
        const rotationControls = document.querySelectorAll('.rotation-control');
        rotationControls.forEach(control => {
            control.classList.toggle('disabled', !enabled);
        });
    }
    
    initializeControls() {
        // Motion toggle
        const motionToggle = document.getElementById('motionToggle');
        if (motionToggle) {
            motionToggle.addEventListener('change', (e) => {
                this.settings.motionEnabled = e.target.checked;
                this.toggleRotationControls(this.settings.motionEnabled);
                
                if (!this.settings.motionEnabled) {
                    this.resetToNeutral();
                }
            });
        }

        // Duplicate visibility toggle
        const duplicateVisible = document.getElementById('duplicateVisible');
        if (duplicateVisible) {
            duplicateVisible.addEventListener('change', (e) => {
                this.settings.duplicateVisible = e.target.checked;
                this.toggleDuplicateControls(this.settings.duplicateVisible);
                this.updateDuplicateVisibility();
            });
        }

        // Shadows toggle
        const shadowsToggle = document.getElementById('svgShadowsToggle');
        if (shadowsToggle) {
            shadowsToggle.addEventListener('change', (e) => {
                this.toggleShadows(e.target.checked);
                this.resetToNeutral();
            });
        }

        // Grain toggle
        const grainToggle = document.getElementById('grainToggle');
        if (grainToggle) {
            grainToggle.addEventListener('change', (e) => {
                this.toggleGrain(e.target.checked);
            });
        }

        // Slider controls
        this.attachSliderListener('duplicateScale', 'duplicateScale');
        this.attachSliderListener('duplicateOpacity', 'duplicateOpacity');
        this.attachSliderListener('duplicateYOffset', 'duplicateYOffset');
        this.attachSliderListener('duplicateBlur', 'duplicateBlur');
        this.attachSliderListener('rotationX', 'maxTiltX');
        this.attachSliderListener('rotationY', 'maxTiltY');
        this.attachGrainSliderListener('grainScale', 'grainScale');
        this.attachGrainSliderListener('grainIntensity', 'grainIntensity');
        this.attachGrainSliderListener('grainBias', 'grainBias');
        this.attachGrainSliderListener('grainOpacity', 'grainOpacity');
    }
    
    attachSliderListener(controlName, settingName) {
        const control = document.getElementById(controlName);
        const display = document.getElementById(controlName + 'Value');
        
        if (!control || !display) return;
        
        control.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            display.textContent = value;
            this.settings[settingName] = value;
            
            if (!this.settings.motionEnabled) {
                this.resetToNeutral();
            }
        });
    }
    
    attachGrainSliderListener(controlName, settingName) {
        const control = document.getElementById(controlName);
        const display = document.getElementById(controlName + 'Value');
        
        if (!control || !display) {
            console.warn('Grain slider not found:', controlName);
            return;
        }
        
        control.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            display.textContent = value;
            this.settings[settingName] = value;
            
            if (this.grainRenderer && this.settings.grainEnabled) {
                this.grainRenderer.updateGrainSettings(this.settings);
            }
        });
    }
    
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.cardSystem = new SimpleCardSystem();
    
    // Debug helper functions
    window.debugGrain = (enabled) => {
        if (window.cardSystem && window.cardSystem.grainRenderer) {
            window.cardSystem.setGrainDebugMode(enabled);
        }
    };
    
    // 3D Card system initialized
});
</script>
</body>
</html>