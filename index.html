<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Card Prototype</title>
    <style>
        :root {
            --card-width: 270px;
            --card-height: 400px;
            --card-ratio: calc(var(--card-width) / var(--card-height));
            --shine-mask-base: calc(min(var(--card-height), 50vmin) * 0.4);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            font-family: -apple-system, Arial, sans-serif;
            display: grid;
            grid-template-columns: 300px minmax(0, 1fr);
            grid-template-areas: "sidebar content";
            overflow: hidden;
        }

        .app-sidebar {
            grid-area: sidebar;
            height: 100vh;
            background: #f7f7f7;
            padding: 20px;
            overflow-y: auto;
        }

        .app-content {
            grid-area: content;
            height: 100vh;
            background-color: #ffffff;
            overflow: visible;
        }

        .content-scroll-wrapper {
            height: 100%;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .image-container {
            text-align: center;
            max-width: var(--card-width);
            max-height: 500px;
            position: relative;
            transform-style: preserve-3d;
            perspective: 1000px;
            perspective-origin: 50% 50%;
            overflow: visible;
        }

        .duplicate-image {
            position: absolute;
            border-radius: 32px;
            top: 0;
            left: 0;
            width: var(--card-width);
            height: var(--card-height);
            transform: var(--dup-transform, rotateX(0deg) rotateY(0deg) translateZ(-5px) scale(1) translate(0px, 0px));
            transform-origin: 50% 50%;
            filter: blur(var(--blur, 24px));
            opacity: var(--opacity, 0.7);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), filter 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backface-visibility: hidden;
        }

        .centered-image {
            border-radius: 32px;
            position: relative;
            width: var(--card-width);
            height: var(--card-height);
            transform: rotateX(var(--rot-x, 0deg)) rotateY(var(--rot-y, 0deg)) translateZ(0px);
            transform-origin: 50% 50%;
            transform-style: preserve-3d;
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), background-position 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backface-visibility: hidden;
            background-position: 50% 50%;
            will-change: transform, background-position;
            box-shadow: 
                var(--shadow-x-1, 0px) var(--shadow-y-1, 6px) 8px rgba(0,0,0,0.04),
                var(--shadow-x-2, 0px) var(--shadow-y-2, 18px) 24px rgba(0,0,0,0.08),
                var(--shadow-x-3, 0px) var(--shadow-y-3, 36px) 48px rgba(0,0,0,0.16);
        }

        .image-wrapper {
            width: var(--card-width);
            height: var(--card-height);
            margin: 0;
            padding: 0;
            line-height: 0;
            display: block;
            position: relative;
            transform-style: preserve-3d;
            overflow: visible;
        }


        .image-container.mouse-leave .duplicate-image,
        .image-container.mouse-leave .centered-image {
            transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .control-group {
            margin-bottom: 15px;
            margin-top: 15px;
        }
        
        .control-group:first-of-type {
            margin-top: 10px;
        }

        .control-group .heading {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .control-group .heading span {
            font-weight: 500;
            color: #666;
        }

        .app-sidebar h4 {
            padding-top: 24px;
            margin: 0;
        }
        
        .app-sidebar > h4:first-child {
            padding-top: 0;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FF5A5F;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        /* SELECT DROPDOWN STYLING */
        .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            font-family: inherit;
            font-size: 12px;
            color: #333;
            cursor: pointer;
        }

        .control-group select:focus {
            outline: none;
            border-color: #007AFF;
            box-shadow: 0 0 0 1px rgba(0, 122, 255, 0.2);
        }

        .control-group select:hover {
            border-color: #999;
        }

        /* FILE INPUT STYLING */
        .control-group input[type="file"] {
            width: 100%;
            margin-bottom: 8px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
        }

        /* BUTTON STYLING */
        .control-group button {
            width: 100%;
            padding: 6px 12px;
            background: transparent;
            color: #222;
            border: 1px solid #222;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-family: inherit;
        }

        .control-group button:hover {
            background: #222;
            color: white;
        }

        /* UPLOAD STATUS TEXT */
        #uploadStatus {
            margin-top: 8px;
            font-size: 11px;
            color: #666;
        }

        .control-group.disabled {
            display: none;
            pointer-events: none;
        }

        .control-group.checkbox {
            padding-top: 16px;
            margin: 16px 0px;
        }

        /* SHINE EFFECT - Dynamic light reflection that follows mouse position */
        .shine {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            /* Fallback: 5-stop gradient matching JavaScript structure */
            background: linear-gradient(90deg, 
                rgba(255,255,255,0.2) 0%, 
                rgba(255,255,255,0.15) 15%, 
                rgba(255,255,255,0.1) 30%, 
                rgba(255,255,255,0.05) 45%, 
                rgba(255,255,255,0) 60%);
            border-radius: 32px;
            pointer-events: none;
            opacity: 0; /* Hidden by default, shown based on mouse distance */
            transition: opacity 0.3s ease-out;
            /* Performance optimizations */
            will-change: opacity, background;
            contain: layout style paint;
            /* Blend mode for effects */
            mix-blend-mode: var(--effects-blend-mode, normal);
            /* Simplified elliptical mask with fixed values for debugging */
            mask-image: radial-gradient(
                ellipse 108px 160px at center, 
                transparent 0px,        /* Start transparent */
                transparent 32px,       /* Stay transparent to 32px */
                rgba(0,0,0,0.1) 40px,   /* Very gradual start */
                rgba(0,0,0,0.3) 60px,   /* Increase */
                rgba(0,0,0,0.6) 80px,   /* More visible */
                rgba(0,0,0,0.9) 120px,  /* Almost full */
                black 160px);           /* Fully visible */
            -webkit-mask-image: radial-gradient(
                ellipse 108px 160px at center, 
                transparent 0px,
                transparent 32px,
                rgba(0,0,0,0.1) 40px,
                rgba(0,0,0,0.3) 60px,
                rgba(0,0,0,0.6) 80px,
                rgba(0,0,0,0.9) 120px,
                black 160px);
        }

        .shine.active {
            opacity: 1; /* Visible when mouse is in active zone */
        }

        /* EDGE INNER SHADOW - Dynamic inset shadows that follow mouse position */
        .edge-inner-shadow {
            content: '';
            position: absolute;
            top: -1px;
            left: 0px;
            opacity: var(--inner-shadow-opacity, 0.5);
            /* Dynamic inset shadows using CSS variables updated by JavaScript */
            box-shadow: 
                0 0 0px white, 
                inset var(--inner-light-x, 1px) var(--inner-light-y, 1px) 2px white, 
                inset var(--inner-dark-x, -1px) var(--inner-dark-y, -1px) 2px black, 
                inset var(--inner-shadow-light-x, -8px) var(--inner-shadow-light-y, -7px) 10px transparent, 
                inset var(--inner-shadow-dark-x, 4px) var(--inner-shadow-dark-y, 7px) 10px transparent;
            width: 100%;
            mix-blend-mode: var(--effects-blend-mode, normal);
            height: 100%;
            border-radius: 33px;
            z-index: -1;
            transition: box-shadow 0.3s ease-out;
        }

    </style>
</head>
<body>

    <div class="app-sidebar">
        <h4>Image</h4>
        <div class="control-group">
            <input type="file" id="imageUpload" accept="image/png,image/jpeg">
            <button id="resetImage">Remove Image</button>
            <div id="uploadStatus"></div>
        </div>

        <h4>Effects</h4>
        <!-- Master toggle for both shine and inner shadow effects -->
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="shineToggle" checked> 
                Visible
            </label>
        </div>
        
        <!-- Shine brightness control (0-100%) -->
        <div class="control-group">
            <div class="control-header">
                <span>Shine Intensity</span>
                <span><span id="shineIntensityValue">33</span>%</span>
            </div>
            <input type="range" id="shineIntensity" min="0" max="100" value="33" step="1">
        </div>
        
        <!-- Inner shadow opacity control (0-100%) -->
        <div class="control-group">
            <div class="control-header">
                <span>Inner Shadow Opacity</span>
                <span><span id="innerShadowOpacityValue">50</span>%</span>
            </div>
            <input type="range" id="innerShadowOpacity" min="0" max="100" value="50" step="1">
        </div>
        
        <!-- Toggle: light appears where mouse is vs opposite corner -->
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="invertEffects" checked> 
                Follows cursor
            </label>
        </div>
        <!-- Makes shine and shadow appear in different corners -->
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="oppositeCorners"> 
                Opposite Corners
            </label>
        </div>
        
        <!-- Blend mode for both shine and inner shadow effects -->
        <div class="control-group">
            <div class="control-header">
                <span>Effects Blend Mode</span>
            </div>
            <select id="effectsBlendMode">
                <option value="normal">Normal</option>
                <option value="screen">Screen</option>
                <option value="overlay">Overlay</option>
            </select>
        </div>

        <h4>Parallax</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="parallaxToggle" checked> 
                Background Parallax
            </label>
        </div>
        
        <div class="control-group">
            <div class="heading">
                <label for="parallaxIntensity">Intensity</label>
                <span><span id="parallaxIntensityValue">2</span>%</span>
            </div>
            <input type="range" id="parallaxIntensity" min="0" max="10" value="2" step="1">
        </div>

        <h4>Card</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="motionToggle" checked> 
                Interactive
            </label>
        </div>

        <div class="control-group rotation-control">
            <div class="heading">
                <label for="rotationX">X Rotation</label>
                <span><span id="rotationXValue">4</span>°</span>
            </div>
            <input type="range" id="rotationX" min="0" max="20" value="4" step="1">
        </div>
        
        <div class="control-group rotation-control">
            <div class="heading">
                <label for="rotationY">Y Rotation</label>
                <span><span id="rotationYValue">4</span>°</span>
            </div>
            <input type="range" id="rotationY" min="0" max="20" value="4" step="1">
        </div>

        <h4>Duplicate</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="duplicateVisible" checked> 
                Visible
            </label>
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateScale">Scale</label>
                <span><span id="duplicateScaleValue">100</span>%</span>
            </div>
            <input type="range" id="duplicateScale" min="50" max="100" value="100" step="1">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateOpacity">Opacity</label>
                <span><span id="duplicateOpacityValue">70</span>%</span>
            </div>
            <input type="range" id="duplicateOpacity" min="0" max="100" value="70" step="1">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateYOffset">Y Offset</label>
                <span><span id="duplicateYOffsetValue">18</span>px</span>
            </div>
            <input type="range" id="duplicateYOffset" min="0" max="64" value="18" step="1">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateBlur">Blur</label>
                <span><span id="duplicateBlurValue">24</span>px</span>
            </div>
            <input type="range" id="duplicateBlur" min="0" max="48" value="24" step="1">
        </div>

        <h4>Grain</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="grainToggle" checked> 
                Visible
            </label>
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainScale">Grain Scale</label>
                <span><span id="grainScaleValue">0.03</span></span>
            </div>
            <input type="range" id="grainScale" min="0.01" max="0.1" value="0.03" step="0.005">
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainIntensity">Grain Intensity</label>
                <span><span id="grainIntensityValue">1</span></span>
            </div>
            <input type="range" id="grainIntensity" min="0.0" max="3.0" value="1" step="0.1">
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainBias">Grain Bias</label>
                <span><span id="grainBiasValue">0</span></span>
            </div>
            <input type="range" id="grainBias" min="-1.0" max="1.0" value="0" step="0.1">
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainOpacity">Grain Opacity</label>
                <span><span id="grainOpacityValue">0.3</span></span>
            </div>
            <input type="range" id="grainOpacity" min="0.0" max="1.0" value="0.3" step="0.05">
        </div>

        <h4>Shadows</h4>

        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="svgShadowsToggle" checked> 
                Visible
            </label>
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="shadowOpacity">Shadows Opacity</label>
                <span><span id="shadowOpacityValue">100</span>%</span>
            </div>
            <input type="range" id="shadowOpacity" min="0" max="200" value="100" step="5">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="shadowOffset">Shadows Offset</label>
                <span><span id="shadowOffsetValue">100</span>%</span>
            </div>
            <input type="range" id="shadowOffset" min="0" max="200" value="100" step="5">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="shadowBlur">Shadows Blur</label>
                <span><span id="shadowBlurValue">100</span>%</span>
            </div>
            <input type="range" id="shadowBlur" min="0" max="200" value="100" step="5">
        </div>
    </div>

    <div class="app-content">
        <div class="content-scroll-wrapper">
            <div class="cards-wrapper" id="cardsWrapper">
            <div class="image-container" data-card="1">
                <div class="image-wrapper">
                    <canvas id="grainCanvas" class="grain-shadow" width="1480" height="1620" 
                            style="position: absolute; width: 740px; height: 810px; 
                                   top: -285px; left: -235px; pointer-events: none;
                                   transform-origin: 50% 50%;
                                   backface-visibility: hidden;
                                   display: block;"></canvas>
                    <div class="duplicate-image" style="background: url('./assets/sofa.jpg'), linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%); background-size: cover; background-position: 50% 50%; background-repeat: no-repeat;"></div>
                    <div class="centered-image" style="background: url('./assets/sofa.jpg'), linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%); background-size: cover; background-position: 50% 50%; background-repeat: no-repeat;">
                        <div class="shine"></div>
                        <div class="edge-inner-shadow"></div>
                    </div>
                </div>                 
            </div>
        </div>
        </div>
    </div>

<script>
class GrainShadowRenderer {
    constructor(canvas, settings) {
        this.canvas = canvas;
        this.settings = settings;
        this.debugMode = false; // Disable debug mode to test shadows
        this.gl = canvas.getContext('webgl', {
            alpha: true,
            premultipliedAlpha: false
        });
        
        if (!this.gl) {
            throw new Error('WebGL not supported');
        }
        
        this.program = this.createShaderProgram();
        this.setupGeometry();
        this.setupUniforms();
        
        this.shadowOffsets = {
            offset1: [0, 6],
            offset2: [0, 18],
            offset3: [0, 36]
        };
        
        this.render();
    }
    
    createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }
        
        return shader;
    }
    
    createShaderProgram() {
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            
            void main() {
                v_uv = (a_position + 1.0) * 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
        
        const fragmentShaderSource = `
            precision mediump float;
            
            uniform vec2 u_resolution;
            uniform vec2 u_shadowOffset1;
            uniform vec2 u_shadowOffset2;
            uniform vec2 u_shadowOffset3;
            uniform float u_grainScale;
            uniform float u_grainIntensity;
            uniform float u_grainBias;
            uniform float u_grainOpacity;
            uniform bool u_debugMode;
            
            varying vec2 v_uv;
            
            // Hash function for noise
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            
            // 2D hash
            vec2 hash2(vec2 p) {
                return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);
            }
            
            // Simplex noise
            float simplexNoise(vec2 p) {
                const float K1 = 0.366025404;
                const float K2 = 0.211324865;
                
                vec2 i = floor(p + (p.x + p.y) * K1);
                vec2 a = p - i + (i.x + i.y) * K2;
                float m = step(a.y, a.x);
                vec2 o = vec2(m, 1.0 - m);
                vec2 b = a - o + K2;
                vec2 c = a - 1.0 + 2.0 * K2;
                
                vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
                vec3 n = h * h * h * h * vec3(
                    dot(a, hash2(i) * 2.0 - 1.0),
                    dot(b, hash2(i + o) * 2.0 - 1.0),
                    dot(c, hash2(i + 1.0) * 2.0 - 1.0)
                );
                
                return dot(n, vec3(70.0)) * 0.5 + 0.5;
            }
            
            // Rounded rectangle SDF
            float roundedRectSDF(vec2 pos, vec2 size, float radius) {
                return length(max(abs(pos) - size + radius, 0.0)) - radius;
            }
            
            // Drop shadow with grain
            float dropShadow(vec2 fragCoord, vec2 center, vec2 size, float radius, vec2 offset, float blur, float opacity) {
                vec2 shadowCenter = center + offset;
                vec2 localPos = fragCoord - shadowCenter;
                float dist = roundedRectSDF(localPos, size * 0.5, radius);
                
                float shadow = 1.0 - smoothstep(-blur, blur, dist);
                return shadow * opacity;
            }
            
            void main() {
                // Flip Y coordinate to match CSS coordinate system (top-left origin)
                vec2 uv_flipped = vec2(v_uv.x, 1.0 - v_uv.y);
                vec2 fragCoord = uv_flipped * vec2(740.0, 810.0);
                
                // Debug mode: render test pattern
                if (u_debugMode) {
                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Solid red background
                    return;
                }
                
                // Card parameters - center positioned within large canvas  
                vec2 rectSize = vec2(270.0, 400.0); // Card size in CSS pixels
                float cornerRadius = 32.0; // Corner radius in CSS pixels  
                vec2 center = vec2(370.0, 485.0); // Card center: (235 + 135, 285 + 200) in canvas space
                
                // Single grainy shadow matching middle shadow (shadow-2) specifications
                float shadow = dropShadow(fragCoord, center, rectSize, cornerRadius, u_shadowOffset2, 24.0, u_grainOpacity);
                
                // Apply grain effect with overlay blending
                if (shadow > 0.0) {
                    vec2 noiseCoord = fragCoord / 100.0;
                    float frequency = 1.0 / u_grainScale;
                    float noiseValue = simplexNoise(noiseCoord * frequency);
                    
                    // Apply bias
                    noiseValue += u_grainBias * 0.3;
                    
                    // Create overlay blend: if noise < 0.5, darken; if > 0.5, lighten
                    float overlayGrain;
                    if (noiseValue < 0.5) {
                        // Darken: 2 * base * overlay
                        overlayGrain = 2.0 * shadow * noiseValue;
                    } else {
                        // Lighten: 1 - 2 * (1 - base) * (1 - overlay)
                        overlayGrain = 1.0 - 2.0 * (1.0 - shadow) * (1.0 - noiseValue);
                    }
                    
                    // Mix original shadow with overlay grain based on intensity
                    shadow = mix(shadow, overlayGrain, u_grainIntensity * 0.3);
                    shadow = clamp(shadow, 0.0, 1.0);
                }
                
                // Output black shadow with transparency
                gl_FragColor = vec4(0.0, 0.0, 0.0, shadow);
            }
        `;
        
        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        const program = this.gl.createProgram();
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);
        
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            console.error('Program linking error:', this.gl.getProgramInfoLog(program));
            return null;
        }
        
        return program;
    }
    
    setupGeometry() {
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        
        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
        
        this.positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
    }
    
    setupUniforms() {
        this.uniforms = {
            resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
            shadowOffset1: this.gl.getUniformLocation(this.program, 'u_shadowOffset1'),
            shadowOffset2: this.gl.getUniformLocation(this.program, 'u_shadowOffset2'),
            shadowOffset3: this.gl.getUniformLocation(this.program, 'u_shadowOffset3'),
            grainScale: this.gl.getUniformLocation(this.program, 'u_grainScale'),
            grainIntensity: this.gl.getUniformLocation(this.program, 'u_grainIntensity'),
            grainBias: this.gl.getUniformLocation(this.program, 'u_grainBias'),
            grainOpacity: this.gl.getUniformLocation(this.program, 'u_grainOpacity'),
            debugMode: this.gl.getUniformLocation(this.program, 'u_debugMode')
        };
    }
    
    updateShadowOffsets(offsets) {
        this.shadowOffsets = offsets;
        this.render();
    }
    
    updateGrainSettings(settings) {
        this.settings = settings;
        this.render();
    }
    
    setDebugMode(enabled) {
        this.debugMode = enabled;
        this.render();
    }
    
    render() {
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        
        // Enable overlay blending for natural grain effect
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA); // Standard alpha for now
        // Note: True overlay requires fragment shader implementation
        
        this.gl.useProgram(this.program);
        
        // Set uniforms
        this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
        this.gl.uniform2f(this.uniforms.shadowOffset1, this.shadowOffsets.offset1[0], this.shadowOffsets.offset1[1]);
        this.gl.uniform2f(this.uniforms.shadowOffset2, this.shadowOffsets.offset2[0], this.shadowOffsets.offset2[1]);
        this.gl.uniform2f(this.uniforms.shadowOffset3, this.shadowOffsets.offset3[0], this.shadowOffsets.offset3[1]);
        this.gl.uniform1f(this.uniforms.grainScale, this.settings.grainScale);
        this.gl.uniform1f(this.uniforms.grainIntensity, this.settings.grainIntensity);
        this.gl.uniform1f(this.uniforms.grainBias, this.settings.grainBias);
        this.gl.uniform1f(this.uniforms.grainOpacity, this.settings.grainOpacity);
        this.gl.uniform1i(this.uniforms.debugMode, this.debugMode ? 1 : 0);
        
        // Check for WebGL errors
        const error = this.gl.getError();
        if (error !== this.gl.NO_ERROR) {
            console.error('WebGL error after setting uniforms:', error);
        }
        
        // Draw
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(this.positionLocation);
        this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);
        
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
}

class ImageUploadHandler {
    constructor(cardSystem) {
        this.cardSystem = cardSystem;
        this.defaultGradient = 'linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%)';
        this.currentImageUrl = null;
        this.currentImageDimensions = null;
        this.maxSize = 5 * 1024 * 1024; // 5MB  
        this.maxDimension = 2000; // Balanced for performance and quality
        this.statusElement = document.getElementById('uploadStatus');
        // Background size calculation cache
        this.backgroundSizeCache = new Map();
    }
    
    calculateParallaxBackgroundSize(imageW, imageH) {
        // Check cache first
        const cacheKey = `${imageW}x${imageH}`;
        if (this.backgroundSizeCache.has(cacheKey)) {
            return this.backgroundSizeCache.get(cacheKey);
        }
        
        // Use cached container dimensions instead of offsetWidth/Height
        const containerW = this.cardSystem.containerDimensions.width;
        const containerH = this.cardSystem.containerDimensions.height;
        
        // Calculate scale factor (same as background-size: cover)
        const scaleX = containerW / imageW;
        const scaleY = containerH / imageH;
        const coverScale = Math.max(scaleX, scaleY);
        
        // Apply cover scale + 15% overflow for parallax
        const finalScale = coverScale * 1.15;
        
        // Return exact pixel dimensions
        const finalW = Math.round(imageW * finalScale);
        const finalH = Math.round(imageH * finalScale);
        
        const result = `${finalW}px ${finalH}px`;
        
        // Cache the result
        this.backgroundSizeCache.set(cacheKey, result);
        
        return result;
    }
    
    validateFile(file) {
        // Type validation
        if (!['image/png', 'image/jpeg'].includes(file.type)) {
            throw new Error('Only PNG and JPEG files allowed');
        }
        // Size validation  
        if (file.size > this.maxSize) {
            throw new Error('File too large (max 5MB)');
        }
        return true;
    }
    
    async processUpload(file) {
        try {
            this.validateFile(file);
            this.setStatus('Processing image...', 'info');
            
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Dimension validation
                        if (img.width > this.maxDimension || img.height > this.maxDimension) {
                            reject(new Error(`Image too large (max ${this.maxDimension}×${this.maxDimension}px)`));
                            return;
                        }
                        
                        // Clean previous image
                        if (this.currentImageUrl && this.currentImageUrl.startsWith('data:')) {
                            // Don't revoke data URLs, just clear reference
                            this.currentImageUrl = null;
                        }
                        
                        this.currentImageUrl = e.target.result;
                        this.currentImageDimensions = { width: img.width, height: img.height };
                        this.applyImageBackground();
                        this.setStatus(`Image uploaded (${img.width}×${img.height})`, 'success');
                        this.updateRemoveButtonState();
                        resolve();
                    };
                    img.onerror = () => reject(new Error('Invalid image file'));
                    img.src = e.target.result;
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        } catch (error) {
            this.setStatus(error.message, 'error');
            throw error;
        }
    }
    
    applyImageBackground() {
        if (!this.currentImageUrl) {
            console.error('No image URL available to apply');
            return;
        }
        
        const bgStyle = `url(${this.currentImageUrl})`;
        
        // Dynamic sizing based on parallax state
        let bgSize;
        if (this.cardSystem.settings.parallaxEnabled && this.currentImageDimensions) {
            // Parallax ON: Calculate 115% overflow for parallax movement
            bgSize = this.calculateParallaxBackgroundSize(
                this.currentImageDimensions.width,
                this.currentImageDimensions.height
            );
        } else {
            // Parallax OFF: Use cover for optimal quality and performance
            bgSize = 'cover';
        }
        
        // Apply to main card and duplicate only (exclude shadow emulator)
        if (this.cardSystem.mainImage) {
            this.cardSystem.mainImage.style.background = bgStyle;
        } else {
            console.error('Main image element not found');
        }
        
        if (this.cardSystem.duplicateImage) {
            this.cardSystem.duplicateImage.style.background = bgStyle;
        } else {
            console.error('Duplicate image element not found');
        }
        
        // Apply sizing and styling
        [this.cardSystem.mainImage, this.cardSystem.duplicateImage].filter(Boolean).forEach(el => {
            el.style.backgroundSize = bgSize;
            el.style.backgroundRepeat = 'no-repeat';
            el.style.backgroundPosition = '50% 50%';
        });
        
        // Update cached image state after background change
        this.cardSystem.updateImageState();
    }
    
    resetToGradient() {
        if (this.currentImageUrl) {
            this.currentImageUrl = null;
            this.currentImageDimensions = null;
        }
        
        // Restore gradient to main and duplicate cards
        [this.cardSystem.mainImage, this.cardSystem.duplicateImage].filter(Boolean).forEach(el => {
            el.style.background = this.defaultGradient;
            el.style.backgroundSize = '';
            el.style.backgroundRepeat = '';
            el.style.backgroundPosition = '';
        });
        
        this.setStatus('Image removed', 'info');
        this.updateRemoveButtonState();
        
        // Update cached image state after background change
        this.cardSystem.updateImageState();
        
        // Clear file input
        const fileInput = document.getElementById('imageUpload');
        if (fileInput) {
            fileInput.value = '';
        }
    }
    
    setStatus(message, type = 'info') {
        if (this.statusElement) {
            this.statusElement.textContent = message;
            this.statusElement.style.color = type === 'error' ? '#ff4444' : type === 'success' ? '#00aa00' : '#666';
        }
    }
    
    updateRemoveButtonState() {
        const resetButton = document.getElementById('resetImage');
        if (resetButton) {
            // Check if background contains an image URL
            const currentBg = this.cardSystem.mainImage.style.background;
            const hasImage = currentBg.includes('url(');
            
            if (hasImage) {
                // Image is present (default or user) - can be removed
                resetButton.disabled = false;
                resetButton.style.color = '#222';
                resetButton.style.borderColor = '#222';
                resetButton.style.cursor = 'pointer';
            } else {
                // Pure gradient - nothing to remove
                resetButton.disabled = true;
                resetButton.style.color = '#999';
                resetButton.style.borderColor = '#999';
                resetButton.style.cursor = 'not-allowed';
            }
        }
    }
}


class SimpleCardSystem {
    constructor() {
        this.settings = {
            motionEnabled: true,
            shadowsEnabled: true,
            shadowOpacity: 100,
            shadowOffset: 100,
            shadowBlur: 100,
            grainEnabled: true,
            grainScale: 0.03,
            grainIntensity: 1,
            grainBias: 0,
            grainOpacity: 0.3,
            shineEnabled: true,
            effectsVisible: true, // Controls both shine and inner shadow visibility
            shineIntensity: 33, // 0-100, maps to 0.0-0.6 internally (33% = current 0.2)
            innerShadowOpacity: 50, // 0-100, maps to 0.0-1.0 internally (50% = current 0.5)
            invertEffects: true,
            oppositeCorners: false,
            duplicateVisible: true,
            duplicateScale: 100,
            duplicateOpacity: 70,
            duplicateYOffset: 18,
            duplicateBlur: 24,
            maxTiltX: 4,
            maxTiltY: 4,
            parallaxEnabled: true,
            parallaxIntensity: 2,
            effectsBlendMode: 'normal'
        };
        
        this.container = document.querySelector('.image-container');
        this.mainImage = this.container.querySelector('.centered-image');
        this.duplicateImage = this.container.querySelector('.duplicate-image');
        this.shine = this.mainImage.querySelector('.shine');
        this.edgeInnerShadow = this.container.querySelector('.edge-inner-shadow');
        
        // Pre-calculated direction multipliers for performance
        this.shineDirection = -1;  // Default: opposite to mouse
        this.shadowDirection = -1; // Default: opposite to mouse
        
        this.grainCanvas = null;
        this.grainRenderer = null;
        this.maxDuplicateOffset = 15;
        this.imageUploadHandler = null;
        
        // Cache for shadow values to prevent redundant DOM updates
        this.lastShadowX = 0;
        this.lastShadowY = 0;
        
        // Phase 1: Pre-computed constants for performance optimization
        this.extendedZoneFactor = 0.75;
        this.maxNormalized = 1.3;
        this.opacityDistanceFactor = 0.2;
        this.shadowMultipliers = [0.3, 0.6, 1.0];
        this.shadowBaseOffsets = [6, 18, 36];
        
        // Phase 2: Transform change detection
        this.lastRotX = 0;
        this.lastRotY = 0;
        this.lastTranslateX = 0;
        this.lastTranslateY = 0;
        this.transformThreshold = 0.05;
        
        // Parallax optimization caching
        this.hasImageBackground = false;
        this.parallaxFactorX = 0;
        this.parallaxFactorY = 0;
        this.containerDimensions = { width: 270, height: 400 };
        
        
        // Cached computed values that change with settings
        this.duplicateScaleFactor = this.settings.duplicateScale / 100;
        this.duplicateOpacityFactor = this.settings.duplicateOpacity / 100;
        
        this.init();
    }
    
    // Parallax optimization methods
    updateImageState() {
        this.hasImageBackground = this.mainImage.style.background.includes('url(');
    }
    
    updateParallaxFactors() {
        this.parallaxFactorX = this.settings.parallaxIntensity / this.settings.maxTiltX;
        this.parallaxFactorY = this.settings.parallaxIntensity / this.settings.maxTiltY;
    }
    
    updateContainerDimensions() {
        this.containerDimensions = {
            width: this.mainImage.offsetWidth,
            height: this.mainImage.offsetHeight
        };
    }
    
    init() {
        this.initializeGrainCanvas();
        this.initializeControls();
        this.initializeImageUpload();
        this.attachEventListeners();
        this.toggleShadows(this.settings.shadowsEnabled);
        this.toggleGrain(this.settings.grainEnabled);
        this.toggleShine(this.settings.effectsVisible); // Use effectsVisible instead of shineEnabled
        this.updateDirections();
        
        // Initialize optimization caches
        this.updateImageState();
        this.updateParallaxFactors();
        this.updateContainerDimensions();
    }
    
    initializeGrainCanvas() {
        this.grainCanvas = document.getElementById('grainCanvas');
        
        if (this.grainCanvas) {
            try {
                this.grainRenderer = new GrainShadowRenderer(this.grainCanvas, this.settings);
                // Set static grain canvas transform once (safe distance for 4° tilt - 30px safety margin)
                this.grainCanvas.style.transform = 'translateZ(-30px)';
            } catch (e) {
                console.warn('WebGL not available for grain shadows:', e);
                this.settings.grainEnabled = false;
                this.grainCanvas.style.display = 'none';
            }
        }
    }
    
    initializeImageUpload() {
        this.imageUploadHandler = new ImageUploadHandler(this);
        
        // Load default image dimensions
        const defaultImg = new Image();
        defaultImg.onload = () => {
            this.imageUploadHandler.defaultImageDimensions = {
                width: defaultImg.width,
                height: defaultImg.height
            };
            // Apply dynamic sizing to default image
            this.updateDefaultImageSize();
        };
        defaultImg.src = './assets/sofa.jpg';
        
        // File input event listener
        const fileInput = document.getElementById('imageUpload');
        if (fileInput) {
            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        await this.imageUploadHandler.processUpload(file);
                    } catch (error) {
                        console.error('Image upload failed:', error);
                    }
                }
            });
        } else {
            console.error('File input not found');
        }
        
        // Reset button event listener
        const resetButton = document.getElementById('resetImage');
        if (resetButton) {
            resetButton.addEventListener('click', () => {
                this.imageUploadHandler.resetToGradient();
            });
        } else {
            console.error('Reset button not found');
        }
        
        // Initialize button state based on current card background
        this.imageUploadHandler.updateRemoveButtonState();
    }
    
    updateDefaultImageSize() {
        // Dynamic sizing based on parallax state
        let bgSize;
        if (this.settings.parallaxEnabled && this.imageUploadHandler.defaultImageDimensions) {
            // Parallax ON: Calculate 115% overflow for parallax movement
            bgSize = this.imageUploadHandler.calculateParallaxBackgroundSize(
                this.imageUploadHandler.defaultImageDimensions.width,
                this.imageUploadHandler.defaultImageDimensions.height
            );
        } else {
            // Parallax OFF: Use cover for optimal quality and performance
            bgSize = 'cover';
        }
        
        // Update both main and duplicate cards
        [this.mainImage, this.duplicateImage].filter(Boolean).forEach(el => {
            el.style.backgroundSize = bgSize;
        });
        
        // Update cached image state after background change
        this.updateImageState();
    }
    
    attachEventListeners() {
        document.addEventListener('pointermove', (e) => {
            if (!this.settings.motionEnabled) return;
            this.handleMouseMove(e);
        }, { passive: true });
        
        document.addEventListener('pointerleave', () => {
            this.handleMouseLeave();
        }, { passive: true });
        
        // Reset card when mouse enters sidebar (adjustment mode)
        const sidebar = document.querySelector('.app-sidebar');
        if (sidebar) {
            sidebar.addEventListener('mouseenter', () => {
                this.handleMouseLeave();
            }, { passive: true });
        }
    }
    
    handleMouseMove(event) {
        // Check if mouse is over the content area (not sidebar)
        const contentArea = document.querySelector('.app-content');
        const contentBounds = contentArea.getBoundingClientRect();
        
        if (event.clientX < contentBounds.left) {
            // Mouse is in sidebar - don't process movement
            return;
        }
        
        const bounds = this.container.getBoundingClientRect();
        const centerX = bounds.left + bounds.width / 2;
        const centerY = bounds.top + bounds.height / 2;
        
        const mouseX = event.clientX - centerX;
        const mouseY = event.clientY - centerY;
        
        const extendedZoneX = bounds.width * this.extendedZoneFactor;
        const extendedZoneY = bounds.height * this.extendedZoneFactor;
        
        const normalizedX = Math.max(-this.maxNormalized, Math.min(this.maxNormalized, mouseX / extendedZoneX));
        const normalizedY = Math.max(-this.maxNormalized, Math.min(this.maxNormalized, mouseY / extendedZoneY));
        
        const rotX = -normalizedY * this.settings.maxTiltX;
        const rotY = normalizedX * this.settings.maxTiltY;
        const translateX = -normalizedX * this.maxDuplicateOffset;
        const translateY = -normalizedY * this.maxDuplicateOffset;
        
        // Calculate dynamic opacity using pre-computed constants
        const distance = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
        const opacityFactor = 1 - (Math.min(distance, 1.5) * this.opacityDistanceFactor);
        const opacity = Math.max(0.1, this.duplicateOpacityFactor * opacityFactor);
        
        this.applyTransforms(rotX, rotY, translateX, translateY, opacity);
        
        // EDGE INNER SHADOW UPDATE
        if (this.settings.effectsVisible) {
            this.updateInnerShadow(normalizedX, normalizedY);
        }
        
        // SHINE UPDATE
        if (this.settings.effectsVisible && this.settings.shineEnabled) {
            this.updateShine(event, bounds, rotX, rotY);
        }
        
        this.container.classList.remove('mouse-leave');
    }
    
    applyTransforms(rotX, rotY, translateX, translateY, opacity) {
        // Phase 2: Only update if transform values have changed significantly
        const rotChanged = Math.abs(rotX - this.lastRotX) >= this.transformThreshold || Math.abs(rotY - this.lastRotY) >= this.transformThreshold;
        const translateChanged = Math.abs(translateX - this.lastTranslateX) >= this.transformThreshold || Math.abs(translateY - this.lastTranslateY) >= this.transformThreshold;
        
        if (rotChanged || translateChanged) {
            // Standardized transform function order: rotateX() rotateY() translateZ() [scale()] [translate()]
            const baseTransform = `rotateX(${rotX.toFixed(1)}deg) rotateY(${rotY.toFixed(1)}deg)`;
            
            // Main card layer (reference point)
            this.mainImage.style.transform = `${baseTransform} translateZ(0px)`;
            
            // Cache current transform values
            this.lastRotX = rotX;
            this.lastRotY = rotY;
            this.lastTranslateX = translateX;
            this.lastTranslateY = translateY;
        }
        
        // Duplicate layer (only if visible) - always update opacity as it's dynamic
        if (this.settings.duplicateVisible) {
            if (rotChanged || translateChanged) {
                const baseTransform = `rotateX(${rotX.toFixed(1)}deg) rotateY(${rotY.toFixed(1)}deg)`;
                const duplicateTransform = `${baseTransform} translateZ(-5px) scale(${this.duplicateScaleFactor.toFixed(3)}) translate(${translateX.toFixed(1)}px, ${(this.settings.duplicateYOffset + translateY).toFixed(1)}px)`;
                this.duplicateImage.style.setProperty('--dup-transform', duplicateTransform);
            }
            // Update opacity and blur regardless (dynamic based on distance)
            this.duplicateImage.style.setProperty('--opacity', opacity.toFixed(3));
            this.duplicateImage.style.filter = `blur(${this.settings.duplicateBlur}px)`;
        }
        
        // Apply parallax effect to main card background
        if (this.settings.parallaxEnabled && this.hasImageBackground) {
            const bgX = 50 - rotY * this.parallaxFactorY;
            const bgY = 50 + rotX * this.parallaxFactorX;
            
            this.mainImage.style.backgroundPosition = `${bgX}% ${bgY}%`;
        }
        
        if (this.settings.shadowsEnabled && (rotChanged || translateChanged)) {
            this.updateBoxShadows(translateX, translateY);
        }
    }
    
    updateBoxShadows(translateX, translateY) {
        // Only update if shadow values have changed significantly (avoid micro-updates)
        if (Math.abs(translateX - this.lastShadowX) < 0.1 && Math.abs(translateY - this.lastShadowY) < 0.1) {
            return;
        }
        
        // Phase 2: Use pre-computed constants and batch DOM updates
        const shadowXValues = this.shadowMultipliers.map(mult => (translateX * mult).toFixed(2) + 'px');
        const adjustedBaseOffsets = this.shadowBaseOffsets.map(offset => offset * (this.settings.shadowOffset / 100));
        const shadowYValues = this.shadowMultipliers.map((mult, i) => (adjustedBaseOffsets[i] + translateY * mult).toFixed(2) + 'px');
        
        // Batch all shadow property updates
        this.mainImage.style.setProperty('--shadow-x-1', shadowXValues[0]);
        this.mainImage.style.setProperty('--shadow-y-1', shadowYValues[0]);
        this.mainImage.style.setProperty('--shadow-x-2', shadowXValues[1]);
        this.mainImage.style.setProperty('--shadow-y-2', shadowYValues[1]);
        this.mainImage.style.setProperty('--shadow-x-3', shadowXValues[2]);
        this.mainImage.style.setProperty('--shadow-y-3', shadowYValues[2]);
        
        // Update grain renderer if available - use pre-computed values
        if (this.grainRenderer && this.settings.grainEnabled) {
            this.grainRenderer.updateShadowOffsets({
                offset1: [translateX * this.shadowMultipliers[0], adjustedBaseOffsets[0] + translateY * this.shadowMultipliers[0]],
                offset2: [translateX * this.shadowMultipliers[1], adjustedBaseOffsets[1] + translateY * this.shadowMultipliers[1]],
                offset3: [translateX * this.shadowMultipliers[2], adjustedBaseOffsets[2] + translateY * this.shadowMultipliers[2]]
            });
        }
        
        // Cache current values
        this.lastShadowX = translateX;
        this.lastShadowY = translateY;
    }
    
    // SHINE UPDATE METHOD - Distance-based visibility with INVERTED positioning
    updateShine(event, bounds, rotX, rotY) {
        if (!this.shine) return; // Safety check
        
        const centerX = bounds.left + bounds.width / 2;
        const centerY = bounds.top + bounds.height / 2;
        
        const dx = event.clientX - centerX;
        const dy = event.clientY - centerY;
        
        // Calculate distance from center
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate distance to card edge based on angle
        const angle = Math.atan2(dy, dx);
        const halfWidth = bounds.width / 2;
        const halfHeight = bounds.height / 2;
        
        // Find intersection with card rectangle boundary
        let maxDistance;
        const absAngle = Math.abs(angle);
        const halfPi = Math.PI / 2;
        
        if (absAngle <= Math.atan2(halfHeight, halfWidth)) {
            // Intersects with left or right edge
            maxDistance = Math.abs(halfWidth / Math.cos(angle));
        } else if (absAngle >= Math.PI - Math.atan2(halfHeight, halfWidth)) {
            // Intersects with left edge (negative x)
            maxDistance = Math.abs(halfWidth / Math.cos(angle));
        } else {
            // Intersects with top or bottom edge
            maxDistance = Math.abs(halfHeight / Math.sin(angle));
        }
        
        // Clamp normalized distance to 1.0 when outside card
        const normalizedDistance = Math.min(distance / maxDistance, 1.0);
        
        // Simple quadratic intensity based on distance from edge (CSS mask handles center blocking)
        const shineVisibility = Math.pow(normalizedDistance, 2);
        
        // Only proceed if shine should be visible
        if (shineVisibility <= 0) {
            this.shine.style.opacity = '0';
            this.shine.classList.remove('active');
            return;
        }
        
        // Visual: Calculate light reflection angle based on mouse position
        // shineDirection = 1: light follows mouse | -1: light appears opposite corner
        const finalDx = dx * this.shineDirection;
        const finalDy = dy * this.shineDirection;
        
        let gradAngle = Math.atan2(finalDy, finalDx) * (180 / Math.PI);
        if (gradAngle < 0) gradAngle += 360;
        
        const gradientAngle = gradAngle - 90;
        
        // Adjust gradient angle for 3D rotation to prevent artifacts
        const adjustedAngle = gradientAngle - (rotY * 0.5) + (rotX * 0.3);
        
        // Dynamic shine intensity from slider (0-100% → 0.0-0.6 range)
        const shineIntensity = this.settings.shineIntensity / 100 * 0.6;
        const rotationBoost = Math.abs(rotX) + Math.abs(rotY); // Boost intensity when card is tilted
        const rotationMultiplier = 1 + (rotationBoost * 0.05); // 5% boost per degree of tilt
        
        const finalIntensity = shineIntensity * shineVisibility * rotationMultiplier;
        
        // Create smooth 5-stop gradient with linear fade (matches CSS fallback)
        const gradient = `linear-gradient(${adjustedAngle}deg, 
            rgba(255,255,255,${finalIntensity * 1.0}) 0%, 
            rgba(255,255,255,${finalIntensity * 0.75}) 15%, 
            rgba(255,255,255,${finalIntensity * 0.5}) 30%, 
            rgba(255,255,255,${finalIntensity * 0.25}) 45%, 
            rgba(255,255,255,0) 60%)`;
        
        this.shine.style.background = gradient;
        this.shine.style.opacity = shineVisibility.toFixed(3);
        this.shine.classList.add('active');
    }

    // EDGE INNER SHADOW UPDATE METHOD - INVERTED positioning to match shine
    updateInnerShadow(normalizedX, normalizedY) {
        if (!this.container) return;
        
        const overlay = this.container.querySelector('.edge-inner-shadow');
        if (!overlay) return;
        
        // Calculate shadow positions based on invert and opposite corners settings
        const lightIntensity = 2; // Adjust for stronger/weaker effect
        const shadowIntensity = 12; // Adjust for stronger/weaker large shadows
        
        // Visual: Create depth illusion through directional inner shadows
        // direction = 1: shadows follow mouse | -1: shadows appear opposite to mouse
        const direction = this.shadowDirection;
        
        // Apply positioning logic using consistent direction system
        // Small highlight shadows (opposite to main shadow direction) 
        const lightX = -normalizedX * lightIntensity * direction;
        const lightY = -normalizedY * lightIntensity * direction;
        
        // Small dark shadows (same as main shadow direction)
        const darkX = normalizedX * lightIntensity * direction;
        const darkY = normalizedY * lightIntensity * direction;
        
        // Larger soft shadows with base offsets
        const shadowLightX = -normalizedX * shadowIntensity * direction - 8 * direction;
        const shadowLightY = -normalizedY * shadowIntensity * direction - 7 * direction;
        const shadowDarkX = normalizedX * shadowIntensity * direction + 4 * direction;
        const shadowDarkY = normalizedY * shadowIntensity * direction + 4 * direction;
        
        // Apply CSS variables to update edge inner shadow
        overlay.style.setProperty('--inner-light-x', `${lightX.toFixed(1)}px`);
        overlay.style.setProperty('--inner-light-y', `${lightY.toFixed(1)}px`);
        overlay.style.setProperty('--inner-dark-x', `${darkX.toFixed(1)}px`);
        overlay.style.setProperty('--inner-dark-y', `${darkY.toFixed(1)}px`);
        overlay.style.setProperty('--inner-shadow-light-x', `${shadowLightX.toFixed(1)}px`);
        overlay.style.setProperty('--inner-shadow-light-y', `${shadowLightY.toFixed(1)}px`);
        overlay.style.setProperty('--inner-shadow-dark-x', `${shadowDarkX.toFixed(1)}px`);
        overlay.style.setProperty('--inner-shadow-dark-y', `${shadowDarkY.toFixed(1)}px`);
    }
    
    handleMouseLeave() {
        this.container.classList.add('mouse-leave');
        this.resetToNeutral();
        
        // SHINE RESET
        if (this.shine && this.settings.shineEnabled) {
            this.shine.style.opacity = '0';
            this.shine.classList.remove('active');
        }
    }
    
    resetToNeutral() {
        const scale = this.duplicateScaleFactor;
        const opacity = this.duplicateOpacityFactor;
        
        // Reset all transforms to completely flat (0° tilt)
        const neutralBaseTransform = `rotateX(0deg) rotateY(0deg)`;
        
        // All layers reset to completely flat position
        
        // Main card reset
        this.mainImage.style.transform = `${neutralBaseTransform} translateZ(0px)`;
        
        const neutralDuplicateTransform = `${neutralBaseTransform} translateZ(-5px) scale(${scale.toFixed(3)}) translate(0px, ${this.settings.duplicateYOffset}px)`;
        this.duplicateImage.style.setProperty('--dup-transform', neutralDuplicateTransform);
        this.duplicateImage.style.setProperty('--opacity', opacity.toFixed(3));
        this.duplicateImage.style.filter = `blur(${this.settings.duplicateBlur}px)`;
        
        // Reset cached transform values
        this.lastRotX = 0;
        this.lastRotY = 0;
        this.lastTranslateX = 0;
        this.lastTranslateY = 0;
        
        // EDGE INNER SHADOW RESET
        this.resetInnerShadow();
        
        // Reset parallax background position
        if (this.settings.parallaxEnabled) {
            this.mainImage.style.backgroundPosition = '50% 50%';
        }
        
        this.resetBoxShadows();
    }
    
    
    resetBoxShadows() {
        const adjustedBaseOffsets = this.shadowBaseOffsets.map(offset => offset * (this.settings.shadowOffset / 100));
        
        this.mainImage.style.setProperty('--shadow-x-1', '0px');
        this.mainImage.style.setProperty('--shadow-y-1', adjustedBaseOffsets[0].toFixed(2) + 'px');
        
        this.mainImage.style.setProperty('--shadow-x-2', '0px');
        this.mainImage.style.setProperty('--shadow-y-2', adjustedBaseOffsets[1].toFixed(2) + 'px');
        
        this.mainImage.style.setProperty('--shadow-x-3', '0px');
        this.mainImage.style.setProperty('--shadow-y-3', adjustedBaseOffsets[2].toFixed(2) + 'px');
        
        // Reset main shadows with dynamic opacity and blur
        if (this.settings.shadowsEnabled) {
            const opacityMultiplier = this.settings.shadowOpacity / 100;
            const blurMultiplier = this.settings.shadowBlur / 100;
            const baseOpacities = [0.04, 0.08, 0.16];
            const baseBlurs = [8, 24, 48];
            
            this.mainImage.style.boxShadow = `
                var(--shadow-x-1, 0px) var(--shadow-y-1, ${adjustedBaseOffsets[0]}px) ${(baseBlurs[0] * blurMultiplier).toFixed(1)}px rgba(0,0,0,${(baseOpacities[0] * opacityMultiplier).toFixed(3)}),
                var(--shadow-x-2, 0px) var(--shadow-y-2, ${adjustedBaseOffsets[1]}px) ${(baseBlurs[1] * blurMultiplier).toFixed(1)}px rgba(0,0,0,${(baseOpacities[1] * opacityMultiplier).toFixed(3)}),
                var(--shadow-x-3, 0px) var(--shadow-y-3, ${adjustedBaseOffsets[2]}px) ${(baseBlurs[2] * blurMultiplier).toFixed(1)}px rgba(0,0,0,${(baseOpacities[2] * opacityMultiplier).toFixed(3)})`;
        }
    }
    
    // EDGE INNER SHADOW RESET METHOD
    resetInnerShadow() {
        const overlay = this.container?.querySelector('.edge-inner-shadow');
        if (!overlay) return;
        
        // Reset to default values
        overlay.style.setProperty('--inner-light-x', '1px');
        overlay.style.setProperty('--inner-light-y', '1px');
        overlay.style.setProperty('--inner-dark-x', '-1px');
        overlay.style.setProperty('--inner-dark-y', '-1px');
        overlay.style.setProperty('--inner-shadow-light-x', '-8px');
        overlay.style.setProperty('--inner-shadow-light-y', '-7px');
        overlay.style.setProperty('--inner-shadow-dark-x', '4px');
        overlay.style.setProperty('--inner-shadow-dark-y', '4px');
    }
    
    toggleShadows(enabled) {
        this.settings.shadowsEnabled = enabled;
        
        if (enabled) {
            // Use resetBoxShadows to apply current shadow settings
            this.resetBoxShadows();
        } else {
            // Disable shadows
            this.mainImage.style.boxShadow = 'none';
        }
    }
    
    toggleGrain(enabled) {
        this.settings.grainEnabled = enabled;
        
        if (this.grainCanvas && this.grainRenderer) {
            if (enabled) {
                this.grainCanvas.style.display = 'block';
                this.grainRenderer.render();
            } else {
                this.grainCanvas.style.display = 'none';
            }
        }
    }
    
    // SHINE TOGGLE METHOD
    toggleShine(enabled) {
        this.settings.effectsVisible = enabled;
        this.settings.shineEnabled = enabled; // Keep for backward compatibility
        
        // Control SHINE visibility
        if (!enabled && this.shine) {
            this.shine.style.opacity = '0';
            this.shine.classList.remove('active');
        }
        
        // Control INNER SHADOW visibility
        if (this.edgeInnerShadow) {
            if (enabled) {
                // Restore inner shadow opacity from setting
                const opacity = this.settings.innerShadowOpacity / 100;
                this.edgeInnerShadow.style.setProperty('--inner-shadow-opacity', opacity.toFixed(3));
            } else {
                // Hide inner shadow completely
                this.edgeInnerShadow.style.setProperty('--inner-shadow-opacity', '0');
            }
        }
    }
    
    setGrainDebugMode(enabled) {
        if (this.grainRenderer) {
            this.grainRenderer.setDebugMode(enabled);
        }
    }
    
    toggleDuplicateControls(enabled) {
        const duplicateControls = ['duplicateScale', 'duplicateOpacity', 'duplicateYOffset', 'duplicateBlur'];
        duplicateControls.forEach(controlId => {
            const control = document.getElementById(controlId);
            const label = control?.closest('.control-group');
            if (label) {
                label.style.opacity = enabled ? '1' : '0.5';
                control.disabled = !enabled;
            }
        });
    }
    
    updateDuplicateVisibility() {
        if (this.duplicateImage) {
            this.duplicateImage.style.display = this.settings.duplicateVisible ? 'block' : 'none';
        }
    }
    
    // DIRECTION HELPERS: Calculate where light effects appear
    // Visual: Returns 1 when light follows mouse, -1 when light appears opposite to mouse
    getShineDirection() {
        return this.settings.invertEffects ? 1 : -1;
    }
    
    // Visual: Shadow direction creates contrast with shine in "Opposite Corners" mode
    // Normal: both effects opposite to mouse | Inverted: both follow mouse 
    // Opposite Corners: one follows mouse, other appears opposite
    getShadowDirection() {
        const baseDirection = this.settings.invertEffects ? 1 : -1;
        return this.settings.oppositeCorners ? -baseDirection : baseDirection;
    }
    
    // Update pre-calculated direction multipliers when settings change
    updateDirections() {
        this.shineDirection = this.getShineDirection();
        this.shadowDirection = this.getShadowDirection();
    }
    
    toggleRotationControls(enabled) {
        const rotationControls = document.querySelectorAll('.rotation-control');
        rotationControls.forEach(control => {
            control.classList.toggle('disabled', !enabled);
        });
    }
    
    
    initializeControls() {
        // Motion toggle
        const motionToggle = document.getElementById('motionToggle');
        if (motionToggle) {
            motionToggle.addEventListener('change', (e) => {
                this.settings.motionEnabled = e.target.checked;
                this.toggleRotationControls(this.settings.motionEnabled);
                
                if (!this.settings.motionEnabled) {
                    this.resetToNeutral();
                }
            });
        }

        // Duplicate visibility toggle
        const duplicateVisible = document.getElementById('duplicateVisible');
        if (duplicateVisible) {
            duplicateVisible.addEventListener('change', (e) => {
                this.settings.duplicateVisible = e.target.checked;
                this.toggleDuplicateControls(this.settings.duplicateVisible);
                this.updateDuplicateVisibility();
            });
        }

        // Shadows toggle
        const shadowsToggle = document.getElementById('svgShadowsToggle');
        if (shadowsToggle) {
            shadowsToggle.addEventListener('change', (e) => {
                this.toggleShadows(e.target.checked);
            });
        }

        // Grain toggle
        const grainToggle = document.getElementById('grainToggle');
        if (grainToggle) {
            grainToggle.addEventListener('change', (e) => {
                this.toggleGrain(e.target.checked);
            });
        }

        // Shine toggle
        const shineToggle = document.getElementById('shineToggle');
        if (shineToggle) {
            shineToggle.addEventListener('change', (e) => {
                this.toggleShine(e.target.checked);
            });
        }

        // Invert effects toggle
        const invertEffects = document.getElementById('invertEffects');
        if (invertEffects) {
            invertEffects.addEventListener('change', (e) => {
                this.settings.invertEffects = e.target.checked;
                this.updateDirections();
            });
        }

        // Opposite corners toggle
        const oppositeCorners = document.getElementById('oppositeCorners');
        if (oppositeCorners) {
            oppositeCorners.addEventListener('change', (e) => {
                this.settings.oppositeCorners = e.target.checked;
                this.updateDirections();
            });
        }

        // Parallax toggle
        const parallaxToggle = document.getElementById('parallaxToggle');
        if (parallaxToggle) {
            parallaxToggle.addEventListener('change', (e) => {
                this.settings.parallaxEnabled = e.target.checked;
                
                // Update parallax factors and clear background size cache
                this.updateParallaxFactors();
                this.imageUploadHandler.backgroundSizeCache.clear();
                
                // Reapply background sizing based on new parallax state
                if (this.imageUploadHandler.currentImageUrl) {
                    // User uploaded image - reapply with new sizing
                    this.imageUploadHandler.applyImageBackground();
                } else {
                    // Default image - update sizing
                    this.updateDefaultImageSize();
                }
                
                if (!e.target.checked) {
                    // Reset background position when disabled
                    this.mainImage.style.backgroundPosition = '50% 50%';
                }
            });
        }

        // Slider controls
        this.attachSliderListener('duplicateScale', 'duplicateScale');
        this.attachSliderListener('duplicateOpacity', 'duplicateOpacity');
        this.attachSliderListener('duplicateYOffset', 'duplicateYOffset');
        this.attachSliderListener('duplicateBlur', 'duplicateBlur');
        this.attachSliderListener('rotationX', 'maxTiltX');
        this.attachSliderListener('rotationY', 'maxTiltY');
        this.attachSliderListener('shadowOpacity', 'shadowOpacity');
        this.attachSliderListener('shadowOffset', 'shadowOffset');
        this.attachSliderListener('shadowBlur', 'shadowBlur');
        this.attachSliderListener('shineIntensity', 'shineIntensity');
        this.attachSliderListener('innerShadowOpacity', 'innerShadowOpacity');
        this.attachSliderListener('parallaxIntensity', 'parallaxIntensity');
        this.attachDropdownListener('effectsBlendMode', 'effectsBlendMode');
        this.attachGrainSliderListener('grainScale', 'grainScale');
        this.attachGrainSliderListener('grainIntensity', 'grainIntensity');
        this.attachGrainSliderListener('grainBias', 'grainBias');
        this.attachGrainSliderListener('grainOpacity', 'grainOpacity');
    }
    
    attachSliderListener(controlName, settingName) {
        const control = document.getElementById(controlName);
        const display = document.getElementById(controlName + 'Value');
        
        if (!control || !display) return;
        
        control.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            display.textContent = value;
            this.settings[settingName] = value;
            
            // Update cached computed values when relevant settings change
            if (settingName === 'duplicateScale') {
                this.duplicateScaleFactor = value / 100;
            } else if (settingName === 'duplicateOpacity') {
                this.duplicateOpacityFactor = value / 100;
                // Update CSS variable immediately for real-time feedback
                this.duplicateImage.style.setProperty('--opacity', (value / 100).toFixed(3));
            } else if (settingName === 'shadowOpacity' || settingName === 'shadowOffset' || settingName === 'shadowBlur') {
                // Update shadows immediately for real-time feedback
                if (this.settings.shadowsEnabled) {
                    this.resetBoxShadows();
                }
            } else if (settingName === 'innerShadowOpacity') {
                // Update inner shadow opacity CSS variable immediately for real-time feedback
                const opacity = value / 100; // Convert 0-100 to 0.0-1.0
                if (this.edgeInnerShadow) {
                    this.edgeInnerShadow.style.setProperty('--inner-shadow-opacity', opacity.toFixed(3));
                }
            } else if (settingName === 'parallaxIntensity' || settingName === 'maxTiltX' || settingName === 'maxTiltY') {
                // Update parallax factors when intensity or tilt range changes
                this.updateParallaxFactors();
            }
            
            if (!this.settings.motionEnabled) {
                this.resetToNeutral();
            }
        });
    }
    
    attachGrainSliderListener(controlName, settingName) {
        const control = document.getElementById(controlName);
        const display = document.getElementById(controlName + 'Value');
        
        if (!control || !display) {
            console.warn('Grain slider not found:', controlName);
            return;
        }
        
        control.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            display.textContent = value;
            this.settings[settingName] = value;
            
            if (this.grainRenderer && this.settings.grainEnabled) {
                this.grainRenderer.updateGrainSettings(this.settings);
            }
        });
    }
    
    attachDropdownListener(elementId, settingName) {
        const element = document.getElementById(elementId);
        if (!element) {
            console.warn('Dropdown not found:', elementId);
            return;
        }
        
        element.addEventListener('change', (e) => {
            this.settings[settingName] = e.target.value;
            // Apply to both shine and inner shadow elements
            this.shine.style.setProperty('--effects-blend-mode', e.target.value);
            this.edgeInnerShadow.style.setProperty('--effects-blend-mode', e.target.value);
        });
    }
    
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.cardSystem = new SimpleCardSystem();
    
    // Debug helper functions
    window.debugGrain = (enabled) => {
        if (window.cardSystem && window.cardSystem.grainRenderer) {
            window.cardSystem.setGrainDebugMode(enabled);
        }
    };
    
    // 3D Card system initialized
});
</script>
</body>
</html>