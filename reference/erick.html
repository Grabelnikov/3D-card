<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplified 3D Card Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            display: grid;
            grid-template-columns: 300px minmax(0, 1fr);
            grid-template-areas: "sidebar content";
            overflow: hidden;
        }

        .app-sidebar {
            grid-area: sidebar;
            height: 100vh;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow-y: auto;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .app-content {
            grid-area: content;
            height: 100vh;
            background-color: #ffffff;
            overflow: visible;
        }

        .content-scroll-wrapper {
            height: 100%;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .card-title {
            font-size: 20px;
            color: #6C6C6C;
            margin-top: 60px;
            font-weight: 100;
        }

        /* 3D Card Container */
        .image-container {
            text-align: center;
            max-width: 270px;
            max-height: 500px;
            position: relative;
            transform-style: preserve-3d;
            perspective: 1000px;
            perspective-origin: 50% 50%;
            overflow: visible;
        }

        .duplicate-image {
            position: absolute;
            border-radius: 32px;
            top: 0;
            left: 0;
            width: 270px;
            height: 400px;
            transform: rotateX(var(--rot-x, 0deg)) rotateY(var(--rot-y, 0deg)) translateZ(-5px) scale(var(--scale, 1)) translate(var(--tx, 0px), var(--ty, 0px));
            transform-origin: 50% 50%;
            filter: blur(var(--blur, 24px));
            opacity: var(--opacity, 0.6);
            transition: transform 0.3s ease-out, filter 0.3s ease-out, opacity 0.3s ease-out;
            backface-visibility: hidden;
        }

        /* Main Card - Contains shine and edge inner shadow */
        .centered-image {
            border-radius: 32px;
            position: relative;
            width: 270px;
            height: 400px;
            transform: rotateX(var(--rot-x, 0deg)) rotateY(var(--rot-y, 0deg)) translateZ(0px);
            transform-origin: 50% 50%;
            transform-style: preserve-3d;
            transition: transform 0.3s ease-out;
            backface-visibility: hidden;
        }

        .image-wrapper {
            width: 270px;
            height: 400px;
            margin: 0;
            padding: 0;
            line-height: 0;
            display: block;
            position: relative;
            transform-style: preserve-3d;
            overflow: visible;
        }

        /* EDGE INNER SHADOW - Dynamic inset shadows that follow mouse position */
        .edge-inner-shadow {
            content: '';
            position: absolute;
            top: -1px;
            left: 0px;
            opacity: 0.5;
            /* Dynamic inset shadows using CSS variables updated by JavaScript */
            box-shadow: 
                0 0 0px white, 
                inset var(--inner-light-x, 1px) var(--inner-light-y, 1px) 2px white, 
                inset var(--inner-dark-x, -1px) var(--inner-dark-y, -1px) 2px black, 
                inset var(--inner-shadow-light-x, -8px) var(--inner-shadow-light-y, -7px) 10px transparent, 
                inset var(--inner-shadow-dark-x, 4px) var(--inner-shadow-dark-y, 7px) 10px transparent;
            width: 100%;
            mix-blend-mode: screen;
            height: 100%;
            /* background: linear-gradient(45deg, rgba(255, 255, 255, 0.1) 0%, rgba(200, 200, 200, 0.6) 50%, rgba(255, 255, 255, 0.1) 100%); */
            border-radius: 33px;
            z-index: -1;
            transition: box-shadow 0.3s ease-out;
        }

        .transform-container {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transform: rotateX(var(--rot-x, 0deg)) rotateY(var(--rot-y, 0deg));
            transition: transform 0.3s ease-out;
            backface-visibility: hidden;
            overflow: visible;
        }

        .shadow-emulator {
            position: absolute;
            width: 270px;
            height: 400px;
            background: linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%);
            border-radius: 32px;
            transform: rotateX(var(--rot-x, 0deg)) rotateY(var(--rot-y, 0deg)) translateZ(-35px);
            transform-origin: 50% 50%;
            box-shadow: 
                var(--shadow-x-1, 0px) var(--shadow-y-1, 6px) 8px rgba(0,0,0,0.04),
                var(--shadow-x-2, 0px) var(--shadow-y-2, 18px) 24px rgba(0,0,0,0.08),
                var(--shadow-x-3, 0px) var(--shadow-y-3, 36px) 48px rgba(0,0,0,0.16);
            transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
            backface-visibility: hidden;
            top: 0;
            left: 0;
        }

        .image-container.mouse-leave .duplicate-image,
        .image-container.mouse-leave .centered-image,
        .image-container.mouse-leave .shadow-emulator {
            transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.6s ease-out, box-shadow 0.6s ease-out;
        }

        .control-group {
            margin-bottom: 15px;
            margin-top: 15px;
        }
        
        .control-group:first-of-type {
            margin-top: 10px;
        }

        .control-group .heading {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .control-group .heading span {
            font-weight: 500;
            color: #666;
        }

        .app-sidebar h4 {
            padding-top: 24px;
            margin: 0;
        }
        
        .app-sidebar > h4:first-child {
            padding-top: 0;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FF5A5F;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .control-group.disabled {
            display: none;
            pointer-events: none;
        }

        .control-group.checkbox {
            border-top: rgba(255, 255, 255, 0.95) solid 1px;
            padding-top: 16px;
            margin: 16px 0px;
        }

        /* SHINE EFFECT - Dynamic light reflection that follows mouse position */
        .shine {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            /* Dynamic gradient background updated by JavaScript */
            background: linear-gradient(90deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 60%);
            border-radius: 32px;
            pointer-events: none;
            opacity: 0; /* Hidden by default, shown based on mouse distance */
            transition: opacity 0.3s ease-out;
        }

        .shine.active {
            opacity: 1; /* Visible when mouse is in active zone */
        }
    </style>
</head>
<body>
    <!-- SVG Filters for Rotating Shadows -->
    <svg style="position: absolute; width: 0; height: 0; pointer-events: none;">
        <defs>
            <filter id="rotating-shadow" x="-100%" y="-100%" width="300%" height="300%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur1"/>
                <feOffset in="blur1" dx="0" dy="6" result="offset1" id="shadow-offset-1"/>
                <feColorMatrix in="offset1" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.04 0" result="shadow1"/>
                
                <feGaussianBlur in="SourceAlpha" stdDeviation="12" result="blur2"/>
                <feOffset in="blur2" dx="0" dy="18" result="offset2" id="shadow-offset-2"/>
                <feColorMatrix in="offset2" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.08 0" result="shadow2"/>
                
                <feGaussianBlur in="SourceAlpha" stdDeviation="24" result="blur3"/>
                <feOffset in="blur3" dx="0" dy="36" result="offset3" id="shadow-offset-3"/>
                <feColorMatrix in="offset3" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.16 0" result="shadow3"/>
                
                <feMerge>
                    <feMergeNode in="shadow3"/>
                    <feMergeNode in="shadow2"/>
                    <feMergeNode in="shadow1"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
    </svg>

    <div class="app-sidebar">
        <h4>Image</h4>
        <div class="control-group">
            <input type="file" id="imageUpload" accept="image/png,image/jpeg" style="width: 100%; margin-bottom: 8px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
            <button id="resetImage" style="width: 100%; padding: 6px 12px; background: #FF5A5F; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset to Gradient</button>
            <div id="uploadStatus" style="margin-top: 8px; font-size: 11px; color: #666;"></div>
        </div>

        <h4>Card</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="motionToggle" checked> 
                Interactive
            </label>
        </div>

        <div class="control-group rotation-control">
            <div class="heading">
                <label for="rotationX">X Rotation</label>
                <span><span id="rotationXValue">4</span>°</span>
            </div>
            <input type="range" id="rotationX" min="0" max="45" value="4" step="1">
        </div>
        
        <div class="control-group rotation-control">
            <div class="heading">
                <label for="rotationY">Y Rotation</label>
                <span><span id="rotationYValue">4</span>°</span>
            </div>
            <input type="range" id="rotationY" min="0" max="45" value="4" step="1">
        </div>

        <h4>Duplicate</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="duplicateVisible" checked> 
                Visible
            </label>
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateScale">Scale</label>
                <span><span id="duplicateScaleValue">100</span>%</span>
            </div>
            <input type="range" id="duplicateScale" min="50" max="100" value="100" step="1">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateOpacity">Opacity</label>
                <span><span id="duplicateOpacityValue">80</span>%</span>
            </div>
            <input type="range" id="duplicateOpacity" min="0" max="100" value="80" step="1">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateYOffset">Y Offset</label>
                <span><span id="duplicateYOffsetValue">18</span>px</span>
            </div>
            <input type="range" id="duplicateYOffset" min="0" max="64" value="18" step="1">
        </div>

        <div class="control-group">
            <div class="heading">
                <label for="duplicateBlur">Blur</label>
                <span><span id="duplicateBlurValue">24</span>px</span>
            </div>
            <input type="range" id="duplicateBlur" min="0" max="48" value="24" step="1">
        </div>

        <h4>Grain</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="grainToggle" checked> 
                Visible
            </label>
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainScale">Grain Scale</label>
                <span><span id="grainScaleValue">0.03</span></span>
            </div>
            <input type="range" id="grainScale" min="0.01" max="0.1" value="0.03" step="0.005">
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainIntensity">Grain Intensity</label>
                <span><span id="grainIntensityValue">0.5</span></span>
            </div>
            <input type="range" id="grainIntensity" min="0.0" max="3.0" value="0.5" step="0.1">
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainBias">Grain Bias</label>
                <span><span id="grainBiasValue">0.5</span></span>
            </div>
            <input type="range" id="grainBias" min="-1.0" max="1.0" value="0.5" step="0.1">
        </div>

        <div class="control-group grain-control">
            <div class="heading">
                <label for="grainOpacity">Grain Opacity</label>
                <span><span id="grainOpacityValue">0.5</span></span>
            </div>
            <input type="range" id="grainOpacity" min="0.0" max="1.0" value="0.5" step="0.05">
        </div>

        <!-- SHINE & SHADOW CONTROLS -->
        <h4>Effects</h4>
        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="shineToggle" checked> 
                Shine <!-- Controls the shine effect visibility -->
            </label>
        </div>

        <div class="control-group checkbox">
            <label>
                <input type="checkbox" id="svgShadowsToggle" checked> 
                Shadows
            </label>
        </div>
    </div>

    <div class="app-content">
        <div class="content-scroll-wrapper">
            <div class="cards-wrapper" id="cardsWrapper">
            <!-- 3D CARD STRUCTURE -->
            <div class="image-container" data-card="1">
                <div class="image-wrapper">
                    <div class="shadow-emulator" style="background: linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%);"></div>
                    <canvas id="grainCanvas" class="grain-shadow" width="1480" height="1620" 
                            style="position: absolute; width: 740px; height: 810px; 
                                   top: -285px; left: -235px; pointer-events: none;
                                   transform-origin: 50% 50%;
                                   transition: transform 0.3s ease-out;
                                   backface-visibility: hidden;
                                   display: block;"></canvas>
                    <div class="duplicate-image" style="background: linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%);"></div>
                    <!-- MAIN CARD WITH SHINE & EDGE INNER SHADOW -->
                    <div class="centered-image" style="background: linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%);">
                        <div class="shine"></div> <!-- SHINE EFFECT LAYER -->
                        <div class="edge-inner-shadow"></div> <!-- EDGE INNER SHADOW LAYER -->
                    </div>
                </div>                 
            </div>
        </div>
        </div>
    </div>

<script>
class GrainShadowRenderer {
    constructor(canvas, settings) {
        this.canvas = canvas;
        this.settings = settings;
        this.debugMode = false;
        this.gl = canvas.getContext('webgl', {
            alpha: true,
            premultipliedAlpha: false
        });
        
        if (!this.gl) {
            throw new Error('WebGL not supported');
        }
        
        this.program = this.createShaderProgram();
        this.setupGeometry();
        this.setupUniforms();
        
        this.shadowOffsets = {
            offset1: [0, 6],
            offset2: [0, 18],
            offset3: [0, 36]
        };
        
        console.log('GrainShadowRenderer initialized with debug mode enabled');
        this.render();
    }
    
    createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }
        
        return shader;
    }
    
    createShaderProgram() {
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            
            void main() {
                v_uv = (a_position + 1.0) * 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
        
        const fragmentShaderSource = `
            precision mediump float;
            
            uniform vec2 u_resolution;
            uniform vec2 u_shadowOffset1;
            uniform vec2 u_shadowOffset2;
            uniform vec2 u_shadowOffset3;
            uniform float u_grainScale;
            uniform float u_grainIntensity;
            uniform float u_grainBias;
            uniform float u_grainOpacity;
            uniform bool u_debugMode;
            
            varying vec2 v_uv;
            
            // Hash function for noise
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            
            // 2D hash
            vec2 hash2(vec2 p) {
                return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);
            }
            
            // Simplex noise
            float simplexNoise(vec2 p) {
                const float K1 = 0.366025404;
                const float K2 = 0.211324865;
                
                vec2 i = floor(p + (p.x + p.y) * K1);
                vec2 a = p - i + (i.x + i.y) * K2;
                float m = step(a.y, a.x);
                vec2 o = vec2(m, 1.0 - m);
                vec2 b = a - o + K2;
                vec2 c = a - 1.0 + 2.0 * K2;
                
                vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
                vec3 n = h * h * h * h * vec3(
                    dot(a, hash2(i) * 2.0 - 1.0),
                    dot(b, hash2(i + o) * 2.0 - 1.0),
                    dot(c, hash2(i + 1.0) * 2.0 - 1.0)
                );
                
                return dot(n, vec3(70.0)) * 0.5 + 0.5;
            }
            
            // Rounded rectangle SDF
            float roundedRectSDF(vec2 pos, vec2 size, float radius) {
                return length(max(abs(pos) - size + radius, 0.0)) - radius;
            }
            
            // Drop shadow with grain
            float dropShadow(vec2 fragCoord, vec2 center, vec2 size, float radius, vec2 offset, float blur, float opacity) {
                vec2 shadowCenter = center + offset;
                vec2 localPos = fragCoord - shadowCenter;
                float dist = roundedRectSDF(localPos, size * 0.5, radius);
                
                float shadow = 1.0 - smoothstep(-blur, blur, dist);
                return shadow * opacity;
            }
            
            void main() {
                // Flip Y coordinate to match CSS coordinate system (top-left origin)
                vec2 uv_flipped = vec2(v_uv.x, 1.0 - v_uv.y);
                vec2 fragCoord = uv_flipped * vec2(740.0, 810.0);
                
                // Debug mode: render test pattern
                if (u_debugMode) {
                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Solid red background
                    return;
                }
                
                // Card parameters - center positioned within large canvas  
                vec2 rectSize = vec2(270.0, 400.0); // Card size in CSS pixels
                float cornerRadius = 32.0; // Corner radius in CSS pixels  
                vec2 center = vec2(370.0, 485.0); // Card center: (235 + 135, 285 + 200) in canvas space
                
                // Single grainy shadow matching middle shadow (shadow-2) specifications
                float shadow = dropShadow(fragCoord, center, rectSize, cornerRadius, u_shadowOffset2, 24.0, u_grainOpacity);
                
                // Apply grain effect with overlay blending
                if (shadow > 0.0) {
                    vec2 noiseCoord = fragCoord / 100.0;
                    float frequency = 1.0 / u_grainScale;
                    float noiseValue = simplexNoise(noiseCoord * frequency);
                    
                    // Apply bias
                    noiseValue += u_grainBias * 0.3;
                    
                    // Create overlay blend: if noise < 0.5, darken; if > 0.5, lighten
                    float overlayGrain;
                    if (noiseValue < 0.5) {
                        // Darken: 2 * base * overlay
                        overlayGrain = 2.0 * shadow * noiseValue;
                    } else {
                        // Lighten: 1 - 2 * (1 - base) * (1 - overlay)
                        overlayGrain = 1.0 - 2.0 * (1.0 - shadow) * (1.0 - noiseValue);
                    }
                    
                    // Mix original shadow with overlay grain based on intensity
                    shadow = mix(shadow, overlayGrain, u_grainIntensity * 0.3);
                    shadow = clamp(shadow, 0.0, 1.0);
                }
                
                // Output black shadow with transparency
                gl_FragColor = vec4(0.0, 0.0, 0.0, shadow);
            }
        `;
        
        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        const program = this.gl.createProgram();
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);
        
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            console.error('Program linking error:', this.gl.getProgramInfoLog(program));
            console.error('Vertex shader log:', this.gl.getShaderInfoLog(vertexShader));
            console.error('Fragment shader log:', this.gl.getShaderInfoLog(fragmentShader));
            return null;
        }
        
        console.log('WebGL shader program compiled and linked successfully');
        return program;
    }
    
    setupGeometry() {
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        
        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
        
        this.positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
    }
    
    setupUniforms() {
        this.uniforms = {
            resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
            shadowOffset1: this.gl.getUniformLocation(this.program, 'u_shadowOffset1'),
            shadowOffset2: this.gl.getUniformLocation(this.program, 'u_shadowOffset2'),
            shadowOffset3: this.gl.getUniformLocation(this.program, 'u_shadowOffset3'),
            grainScale: this.gl.getUniformLocation(this.program, 'u_grainScale'),
            grainIntensity: this.gl.getUniformLocation(this.program, 'u_grainIntensity'),
            grainBias: this.gl.getUniformLocation(this.program, 'u_grainBias'),
            grainOpacity: this.gl.getUniformLocation(this.program, 'u_grainOpacity'),
            debugMode: this.gl.getUniformLocation(this.program, 'u_debugMode')
        };
    }
    
    updateShadowOffsets(offsets) {
        this.shadowOffsets = offsets;
        this.render();
    }
    
    updateGrainSettings(settings) {
        console.log('GrainShadowRenderer.updateGrainSettings called with:', settings);
        this.settings = settings;
        console.log('About to call render() from updateGrainSettings');
        this.render();
    }
    
    setDebugMode(enabled) {
        this.debugMode = enabled;
        console.log('Debug mode:', enabled ? 'ON' : 'OFF');
        this.render();
    }
    
    render() {
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        
        // Enable overlay blending for natural grain effect
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        
        this.gl.useProgram(this.program);
        
        // Set uniforms
        this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
        this.gl.uniform2f(this.uniforms.shadowOffset1, this.shadowOffsets.offset1[0], this.shadowOffsets.offset1[1]);
        this.gl.uniform2f(this.uniforms.shadowOffset2, this.shadowOffsets.offset2[0], this.shadowOffsets.offset2[1]);
        this.gl.uniform2f(this.uniforms.shadowOffset3, this.shadowOffsets.offset3[0], this.shadowOffsets.offset3[1]);
        this.gl.uniform1f(this.uniforms.grainScale, this.settings.grainScale);
        this.gl.uniform1f(this.uniforms.grainIntensity, this.settings.grainIntensity);
        this.gl.uniform1f(this.uniforms.grainBias, this.settings.grainBias);
        this.gl.uniform1f(this.uniforms.grainOpacity, this.settings.grainOpacity);
        this.gl.uniform1i(this.uniforms.debugMode, this.debugMode ? 1 : 0);
        
        // Check for WebGL errors
        const error = this.gl.getError();
        if (error !== this.gl.NO_ERROR) {
            console.error('WebGL error after setting uniforms:', error);
        }
        
        // Draw
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(this.positionLocation);
        this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);
        
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
}

class ImageUploadHandler {
    constructor(cardSystem) {
        this.cardSystem = cardSystem;
        this.defaultGradient = 'linear-gradient(135deg, #1a1a3a 0%, #8b5cf6 50%, #f0e6ff 100%)';
        this.currentImageUrl = null;
        this.maxSize = 5 * 1024 * 1024; // 5MB  
        this.maxDimension = 2000;
        this.statusElement = document.getElementById('uploadStatus');
    }
    
    validateFile(file) {
        // Type validation
        if (!['image/png', 'image/jpeg'].includes(file.type)) {
            throw new Error('Only PNG and JPEG files allowed');
        }
        // Size validation  
        if (file.size > this.maxSize) {
            throw new Error('File too large (max 5MB)');
        }
        return true;
    }
    
    async processUpload(file) {
        try {
            this.validateFile(file);
            this.setStatus('Processing image...', 'info');
            
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Dimension validation
                        if (img.width > this.maxDimension || img.height > this.maxDimension) {
                            reject(new Error(`Image too large (max ${this.maxDimension}×${this.maxDimension}px)`));
                            return;
                        }
                        
                        // Clean previous image
                        if (this.currentImageUrl && this.currentImageUrl.startsWith('data:')) {
                            // Don't revoke data URLs, just clear reference
                            this.currentImageUrl = null;
                        }
                        
                        this.currentImageUrl = e.target.result;
                        console.log('Image processed, URL length:', this.currentImageUrl.length);
                        this.applyImageBackground();
                        this.setStatus(`Image uploaded (${img.width}×${img.height})`, 'success');
                        resolve();
                    };
                    img.onerror = () => reject(new Error('Invalid image file'));
                    img.src = e.target.result;
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        } catch (error) {
            this.setStatus(error.message, 'error');
            throw error;
        }
    }
    
    applyImageBackground() {
        if (!this.currentImageUrl) {
            console.error('No image URL available to apply');
            return;
        }
        
        const bgStyle = `url(${this.currentImageUrl})`;
        console.log('Applying background:', bgStyle);
        
        // Apply to main card and duplicate only (exclude shadow emulator)
        if (this.cardSystem.mainImage) {
            this.cardSystem.mainImage.style.background = bgStyle;
            console.log('Applied to main image');
        } else {
            console.error('Main image element not found');
        }
        
        if (this.cardSystem.duplicateImage) {
            this.cardSystem.duplicateImage.style.background = bgStyle;
            console.log('Applied to duplicate image');
        } else {
            console.error('Duplicate image element not found');
        }
        
        // Ensure cover/no-repeat styling
        [this.cardSystem.mainImage, this.cardSystem.duplicateImage].filter(Boolean).forEach(el => {
            el.style.backgroundSize = 'cover';
            el.style.backgroundRepeat = 'no-repeat';
            el.style.backgroundPosition = 'center';
        });
    }
    
    resetToGradient() {
        if (this.currentImageUrl) {
            this.currentImageUrl = null;
        }
        
        // Restore gradient to main and duplicate cards
        console.log('Restoring gradient to elements');
        [this.cardSystem.mainImage, this.cardSystem.duplicateImage].filter(Boolean).forEach(el => {
            console.log('Restoring gradient to:', el.className);
            el.style.background = this.defaultGradient;
            el.style.backgroundSize = '';
            el.style.backgroundRepeat = '';
            el.style.backgroundPosition = '';
        });
        
        this.setStatus('Reset to gradient', 'info');
        
        // Clear file input
        const fileInput = document.getElementById('imageUpload');
        if (fileInput) {
            fileInput.value = '';
        }
    }
    
    setStatus(message, type = 'info') {
        if (this.statusElement) {
            this.statusElement.textContent = message;
            this.statusElement.style.color = type === 'error' ? '#ff4444' : type === 'success' ? '#00aa00' : '#666';
        }
    }
}

class SimpleCardSystem {
    constructor() {
        this.settings = {
            motionEnabled: true,
            svgShadowsEnabled: true,
            grainEnabled: true,
            grainScale: 0.03,
            grainIntensity: 0.5,
            grainBias: 0.5,
            grainOpacity: 0.5,
            shineEnabled: true,
            duplicateVisible: true,
            duplicateScale: 100,
            duplicateOpacity: 80,
            duplicateYOffset: 18,
            duplicateBlur: 24,
            maxTiltX: 4,
            maxTiltY: 4
        };
        
        this.container = document.querySelector('.image-container');
        this.wrapper = document.querySelector('.image-wrapper');
        this.shadowEmulator = this.container.querySelector('.shadow-emulator');
        this.mainImage = this.container.querySelector('.centered-image');
        this.duplicateImage = this.container.querySelector('.duplicate-image');
        this.shine = this.container.querySelector('.shine'); // SHINE ELEMENT
        this.grainCanvas = null;
        this.grainRenderer = null;
        this.maxDuplicateOffset = 15;
        this.imageUploadHandler = null;
        
        this.init();
    }
    
    init() {
        this.initializeGrainCanvas();
        this.initializeControls();
        this.initializeImageUpload();
        this.attachEventListeners();
        this.toggleSVGShadows(this.settings.svgShadowsEnabled);
        this.toggleShine(this.settings.shineEnabled);
        this.toggleGrain(this.settings.grainEnabled);
    }
    
    initializeGrainCanvas() {
        this.grainCanvas = document.getElementById('grainCanvas');
        
        if (this.grainCanvas) {
            try {
                this.grainRenderer = new GrainShadowRenderer(this.grainCanvas, this.settings);
            } catch (e) {
                console.warn('WebGL not available for grain shadows:', e);
                this.settings.grainEnabled = false;
                this.grainCanvas.style.display = 'none';
            }
        }
    }
    
    initializeImageUpload() {
        console.log('Initializing image upload handler');
        console.log('Main image element:', this.mainImage ? this.mainImage.className : 'NOT FOUND');
        console.log('Duplicate image element:', this.duplicateImage ? this.duplicateImage.className : 'NOT FOUND');
        
        this.imageUploadHandler = new ImageUploadHandler(this);
        
        // File input event listener
        const fileInput = document.getElementById('imageUpload');
        if (fileInput) {
            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        await this.imageUploadHandler.processUpload(file);
                    } catch (error) {
                        console.error('Image upload failed:', error);
                    }
                }
            });
        } else {
            console.error('File input not found');
        }
        
        // Reset button event listener
        const resetButton = document.getElementById('resetImage');
        if (resetButton) {
            resetButton.addEventListener('click', () => {
                this.imageUploadHandler.resetToGradient();
            });
        } else {
            console.error('Reset button not found');
        }
    }
    
    attachEventListeners() {
        document.addEventListener('pointermove', (e) => {
            if (!this.settings.motionEnabled) return;
            this.handleMouseMove(e);
        }, { passive: true });
        
        document.addEventListener('pointerleave', () => {
            this.handleMouseLeave();
        }, { passive: true });
    }
    
   handleMouseMove(event) {
    const bounds = this.container.getBoundingClientRect();
    const centerX = bounds.left + bounds.width / 2;
    const centerY = bounds.top + bounds.height / 2;
    
    const mouseX = event.clientX - centerX;
    const mouseY = event.clientY - centerY;
    
    const extendedZoneX = bounds.width * 0.75;
    const extendedZoneY = bounds.height * 0.75;
    
    const normalizedX = Math.max(-1.3, Math.min(1.3, mouseX / extendedZoneX));
    const normalizedY = Math.max(-1.3, Math.min(1.3, mouseY / extendedZoneY));
    
    const rotX = -normalizedY * this.settings.maxTiltX;
    const rotY = normalizedX * this.settings.maxTiltY;
    const translateX = -normalizedX * this.maxDuplicateOffset;
    const translateY = -normalizedY * this.maxDuplicateOffset;
    
    // Calculate dynamic opacity
    const distance = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
    const baseOpacity = this.settings.duplicateOpacity / 100;
    const opacityFactor = 1 - (Math.min(distance, 1.5) * 0.2);
    const opacity = Math.max(0.1, baseOpacity * opacityFactor);
    
    this.applyTransforms(rotX, rotY, translateX, translateY, opacity);
    
    // EDGE INNER SHADOW UPDATE
    this.updateInnerShadow(normalizedX, normalizedY);
    
    // SHINE UPDATE
    if (this.settings.shineEnabled) {
        this.updateShine(event, bounds, rotX, rotY);
    }
    
    this.container.classList.remove('mouse-leave');
}
    

    applyTransforms(rotX, rotY, translateX, translateY, opacity) {
        const baseTransform = `rotateX(${rotX.toFixed(1)}deg) rotateY(${rotY.toFixed(1)}deg)`;
        
        // Shadow layer (back-most, positioned for 4° tilt safety)
        this.shadowEmulator.style.transform = `${baseTransform} translateZ(-35px)`;
        
        // Grain canvas layer (safe distance for 4° tilt - 30px safety margin)
        if (this.grainCanvas) {
            this.grainCanvas.style.transform = `translateZ(-30px)`;
        }
        
        // Main card layer (reference point) - shine inherits this transform automatically
        this.mainImage.style.transform = `${baseTransform} translateZ(0px)`;
        
        // Duplicate layer (only if visible)
        if (this.settings.duplicateVisible) {
            const duplicateTransform = `${baseTransform} translateZ(-5px) scale(${(this.settings.duplicateScale / 100).toFixed(3)}) translate(${translateX.toFixed(1)}px, ${(this.settings.duplicateYOffset + translateY).toFixed(1)}px)`;
            this.duplicateImage.style.transform = duplicateTransform;
            this.duplicateImage.style.opacity = opacity.toFixed(3);
            this.duplicateImage.style.filter = `blur(${this.settings.duplicateBlur}px)`;
        }
        
        if (this.settings.svgShadowsEnabled) {
            this.updateBoxShadows(translateX, translateY);
        }
    }
    
    updateBoxShadows(translateX, translateY) {
        this.shadowEmulator.style.setProperty('--shadow-x-1', `${(translateX * 0.3).toFixed(2)}px`);
        this.shadowEmulator.style.setProperty('--shadow-y-1', `${(6 + translateY * 0.3).toFixed(2)}px`);
        
        this.shadowEmulator.style.setProperty('--shadow-x-2', `${(translateX * 0.6).toFixed(2)}px`);
        this.shadowEmulator.style.setProperty('--shadow-x-2', `${(translateX * 0.6).toFixed(2)}px`);
        this.shadowEmulator.style.setProperty('--shadow-y-2', `${(18 + translateY * 0.6).toFixed(2)}px`);
        
        this.shadowEmulator.style.setProperty('--shadow-x-3', `${translateX.toFixed(2)}px`);
        this.shadowEmulator.style.setProperty('--shadow-y-3', `${(36 + translateY).toFixed(2)}px`);
        
        // Update grain renderer if available
        if (this.grainRenderer && this.settings.grainEnabled) {
            this.grainRenderer.updateShadowOffsets({
                offset1: [translateX * 0.3, 6 + translateY * 0.3],
                offset2: [translateX * 0.6, 18 + translateY * 0.6],
                offset3: [translateX, 36 + translateY]
            });
        }
    }
    
    updateSVGShadows(translateX, translateY) {
        const offset1 = document.getElementById('shadow-offset-1');
        const offset2 = document.getElementById('shadow-offset-2');
        const offset3 = document.getElementById('shadow-offset-3');
        
        if (offset1) {
            offset1.setAttribute('dx', (translateX * 0.3).toFixed(2));
            offset1.setAttribute('dy', (6 + translateY * 0.3).toFixed(2));
        }
        
        if (offset2) {
            offset2.setAttribute('dx', (translateX * 0.6).toFixed(2));
            offset2.setAttribute('dy', (18 + translateY * 0.6).toFixed(2));
        }
        
        if (offset3) {
            offset3.setAttribute('dx', translateX.toFixed(2));
            offset3.setAttribute('dy', (36 + translateY).toFixed(2));
        }
    }
    
// EDGE INNER SHADOW UPDATE METHOD - INVERTED positioning to match shine
updateInnerShadow(normalizedX, normalizedY) {
    if (!this.container) return;
    
    const overlay = this.container.querySelector('.edge-inner-shadow');
    if (!overlay) return;
    
    // Calculate shadow positions based on INVERTED mouse position
    // Light source appears to come from opposite direction of mouse (same as shine)
    const lightIntensity = 2; // Adjust for stronger/weaker effect
    const shadowIntensity = 12; // Adjust for stronger/weaker large shadows
    
    // INVERTED LOGIC: Light appears opposite to mouse position
    // Small highlight shadows (same direction as mouse - where mouse pushes the surface down)
    const lightX = normalizedX * lightIntensity;  // CHANGED: removed negation
    const lightY = normalizedY * lightIntensity;  // CHANGED: removed negation
    
    // Small dark shadows (opposite direction to mouse - where light source is)
    const darkX = -normalizedX * lightIntensity;  // CHANGED: added negation
    const darkY = -normalizedY * lightIntensity;  // CHANGED: added negation
    
    // Larger soft shadows (matching the inverted logic)
    const shadowLightX = normalizedX * shadowIntensity + 4;   // CHANGED: inverted and swapped offset
    const shadowLightY = normalizedY * shadowIntensity + 4;   // CHANGED: inverted and swapped offset
    const shadowDarkX = -normalizedX * shadowIntensity - 8;   // CHANGED: inverted and swapped offset
    const shadowDarkY = -normalizedY * shadowIntensity - 7;   // CHANGED: inverted and swapped offset
    
    // Apply CSS variables to update edge inner shadow
    overlay.style.setProperty('--inner-light-x', `${lightX.toFixed(1)}px`);
    overlay.style.setProperty('--inner-light-y', `${lightY.toFixed(1)}px`);
    overlay.style.setProperty('--inner-dark-x', `${darkX.toFixed(1)}px`);
    overlay.style.setProperty('--inner-dark-y', `${darkY.toFixed(1)}px`);
    overlay.style.setProperty('--inner-shadow-light-x', `${shadowLightX.toFixed(1)}px`);
    overlay.style.setProperty('--inner-shadow-light-y', `${shadowLightY.toFixed(1)}px`);
    overlay.style.setProperty('--inner-shadow-dark-x', `${shadowDarkX.toFixed(1)}px`);
    overlay.style.setProperty('--inner-shadow-dark-y', `${shadowDarkY.toFixed(1)}px`);
} 
    
  // SHINE UPDATE METHOD - Distance-based visibility with INVERTED positioning
updateShine(event, bounds, rotX, rotY) {
    const centerX = bounds.left + bounds.width / 2;
    const centerY = bounds.top + bounds.height / 2;
    
    const dx = event.clientX - centerX;
    const dy = event.clientY - centerY;
    
    // Calculate distance from center
    const distance = Math.sqrt(dx * dx + dy * dy);
    const maxDistance = Math.sqrt(bounds.width * bounds.width + bounds.height * bounds.height) / 2;
    const normalizedDistance = Math.min(distance / maxDistance, 1);
    
    // Create dead zone in center where shine is minimal/invisible
    const deadZoneRadius = 0.3; // 30% of max distance = no shine zone
    const fadeZoneRadius = 0.8; // 80% of max distance = full shine starts
    
    let shineVisibility;
    if (normalizedDistance < deadZoneRadius) {
        // Dead zone: no shine
        shineVisibility = 0;
    } else if (normalizedDistance < fadeZoneRadius) {
        // Fade zone: gradual increase
        const fadeProgress = (normalizedDistance - deadZoneRadius) / (fadeZoneRadius - deadZoneRadius);
        shineVisibility = fadeProgress * 0.3; // Max 30% opacity in fade zone
    } else {
        // Active zone: full shine with distance-based intensity
        const activeProgress = (normalizedDistance - fadeZoneRadius) / (1 - fadeZoneRadius);
        shineVisibility = 0.3 + (activeProgress * 0.7); // 30% to 100% opacity
    }
    
    // Only proceed if shine should be visible
    if (shineVisibility <= 0) {
        this.shine.style.opacity = '0';
        this.shine.classList.remove('active');
        return;
    }
    
    // INVERTED POSITIONING: Calculate shine angle from OPPOSITE direction
    // Instead of using mouse position directly, use inverted coordinates
    const invertedDx = -dx; // Invert X direction
    const invertedDy = -dy; // Invert Y direction
    
    let angle = Math.atan2(invertedDy, invertedDx) * (180 / Math.PI);
    if (angle < 0) angle += 360;
    
    const gradientAngle = angle - 90;
    
    // Adjust gradient angle for 3D rotation to prevent artifacts
    const adjustedAngle = gradientAngle - (rotY * 0.5) + (rotX * 0.3);
    
    // Base intensity calculation
    const baseIntensity = 0.2;
    const rotationBoost = Math.abs(rotX) + Math.abs(rotY); // Boost intensity when card is tilted
    const rotationMultiplier = 1 + (rotationBoost * 0.05); // 5% boost per degree of tilt
    
    const finalIntensity = baseIntensity * shineVisibility * rotationMultiplier;
    
    // Create more sophisticated gradient with multiple stops
    const gradient = `linear-gradient(${adjustedAngle}deg, 
        rgba(255,255,255,${finalIntensity * 0.8}) 0%, 
        rgba(255,255,255,${finalIntensity * 0.6}) 15%, 
        rgba(255,255,255,${finalIntensity * 0.4}) 30%, 
        rgba(255,255,255,${finalIntensity * 0.2}) 50%, 
        rgba(255,255,255,0) 70%)`;
    
    this.shine.style.background = gradient;
    this.shine.style.opacity = shineVisibility.toFixed(3);
    this.shine.classList.add('active');
}
    handleMouseLeave() {
        this.container.classList.add('mouse-leave');
        this.resetToNeutral();
        
        // SHINE RESET
        if (this.shine && this.settings.shineEnabled) {
            this.shine.style.opacity = '0';
            this.shine.classList.remove('active');
        }
    }
    
    resetToNeutral() {
        const scale = this.settings.duplicateScale / 100;
        const opacity = this.settings.duplicateOpacity / 100;
        
        // Reset all transforms using standardized function order
        const neutralBaseTransform = 'rotateX(0deg) rotateY(0deg)';
        
        // All layers reset to neutral using identical rotation values and function order
        this.shadowEmulator.style.transform = `${neutralBaseTransform} translateZ(-10px)`;
        
        // Main card reset - shine inherits this transform automatically
        this.mainImage.style.transform = `${neutralBaseTransform} translateZ(0px)`;
        
        const neutralDuplicateTransform = `${neutralBaseTransform} translateZ(-5px) scale(${scale.toFixed(3)}) translate(0px, ${this.settings.duplicateYOffset}px)`;
        this.duplicateImage.style.transform = neutralDuplicateTransform;
        this.duplicateImage.style.opacity = opacity.toFixed(3);
        this.duplicateImage.style.filter = `blur(${this.settings.duplicateBlur}px)`;
        
        // EDGE INNER SHADOW RESET
        this.resetInnerShadow();
        
        this.resetBoxShadows();
    }

    // EDGE INNER SHADOW RESET METHOD
    resetInnerShadow() {
        const overlay = this.container?.querySelector('.edge-inner-shadow');
        if (!overlay) return;
        
        // Reset to default values
        overlay.style.setProperty('--inner-light-x', '1px');
        overlay.style.setProperty('--inner-light-y', '1px');
        overlay.style.setProperty('--inner-dark-x', '-1px');
        overlay.style.setProperty('--inner-dark-y', '-1px');
        overlay.style.setProperty('--inner-shadow-light-x', '-8px');
        overlay.style.setProperty('--inner-shadow-light-y', '-7px');
        overlay.style.setProperty('--inner-shadow-dark-x', '4px');
        overlay.style.setProperty('--inner-shadow-dark-y', '4px');
    }
    
    resetBoxShadows() {
        this.shadowEmulator.style.setProperty('--shadow-x-1', '0px');
        this.shadowEmulator.style.setProperty('--shadow-y-1', '6px');
        
        this.shadowEmulator.style.setProperty('--shadow-x-2', '0px');
        this.shadowEmulator.style.setProperty('--shadow-y-2', '18px');
        
        this.shadowEmulator.style.setProperty('--shadow-x-3', '0px');
        this.shadowEmulator.style.setProperty('--shadow-y-3', '36px');
    }
    
    resetSVGShadows() {
        const offset1 = document.getElementById('shadow-offset-1');
        const offset2 = document.getElementById('shadow-offset-2');
        const offset3 = document.getElementById('shadow-offset-3');
        
        if (offset1) {
            offset1.setAttribute('dx', '0');
            offset1.setAttribute('dy', '6');
        }
        
        if (offset2) {
            offset2.setAttribute('dx', '0');
            offset2.setAttribute('dy', '18');
        }
        
        if (offset3) {
            offset3.setAttribute('dx', '0');
            offset3.setAttribute('dy', '36');
        }
    }
    
    toggleSVGShadows(enabled) {
        this.settings.svgShadowsEnabled = enabled;
        
        if (enabled) {
            // Use box-shadow approach via shadow-emulator
            this.mainImage.style.filter = 'none';
            this.mainImage.style.boxShadow = 'none';
            this.shadowEmulator.style.display = 'block';
        } else {
            // Hide shadows completely
            this.mainImage.style.filter = 'none';
            this.mainImage.style.boxShadow = 'none';
            this.shadowEmulator.style.display = 'none';
        }
        
        if (!enabled) {
            this.resetBoxShadows();
            this.resetSVGShadows();
        }
    }
    
    // SHINE TOGGLE METHOD
    toggleShine(enabled) {
        this.settings.shineEnabled = enabled;
        
        if (!enabled && this.shine) {
            this.shine.style.opacity = '0';
            this.shine.classList.remove('active');
        }
    }
    
    toggleGrain(enabled) {
        this.settings.grainEnabled = enabled;
        
        if (this.grainCanvas && this.grainRenderer) {
            if (enabled) {
                this.grainCanvas.style.display = 'block';
                this.grainRenderer.render();
            } else {
                this.grainCanvas.style.display = 'none';
            }
        }
    }
    
    setGrainDebugMode(enabled) {
        if (this.grainRenderer) {
            this.grainRenderer.setDebugMode(enabled);
        }
    }
    
    toggleDuplicateControls(enabled) {
        const duplicateControls = ['duplicateScale', 'duplicateOpacity', 'duplicateYOffset', 'duplicateBlur'];
        duplicateControls.forEach(controlId => {
            const control = document.getElementById(controlId);
            const label = control?.closest('.control-group');
            if (label) {
                label.style.opacity = enabled ? '1' : '0.5';
                control.disabled = !enabled;
            }
        });
    }
    
    updateDuplicateVisibility() {
        if (this.duplicateImage) {
            this.duplicateImage.style.display = this.settings.duplicateVisible ? 'block' : 'none';
        }
    }
    
    toggleRotationControls(enabled) {
        const rotationControls = document.querySelectorAll('.rotation-control');
        rotationControls.forEach(control => {
            control.classList.toggle('disabled', !enabled);
        });
    }
    
    initializeControls() {
        // Motion toggle
        const motionToggle = document.getElementById('motionToggle');
        if (motionToggle) {
            motionToggle.addEventListener('change', (e) => {
                this.settings.motionEnabled = e.target.checked;
                this.toggleRotationControls(this.settings.motionEnabled);
                
                if (!this.settings.motionEnabled) {
                    this.resetToNeutral();
                }
            });
        }

        // Duplicate visibility toggle
        const duplicateVisible = document.getElementById('duplicateVisible');
        if (duplicateVisible) {
            duplicateVisible.addEventListener('change', (e) => {
                this.settings.duplicateVisible = e.target.checked;
                this.toggleDuplicateControls(this.settings.duplicateVisible);
                this.updateDuplicateVisibility();
            });
        }

        // Shadows toggle
        const svgShadowsToggle = document.getElementById('svgShadowsToggle');
        if (svgShadowsToggle) {
            svgShadowsToggle.addEventListener('change', (e) => {
                this.toggleSVGShadows(e.target.checked);
                this.resetToNeutral();
            });
        }

        // SHINE TOGGLE CONTROL
        const shineToggle = document.getElementById('shineToggle');
        if (shineToggle) {
            shineToggle.addEventListener('change', (e) => {
                this.toggleShine(e.target.checked);
            });
        }

        // Grain toggle
        const grainToggle = document.getElementById('grainToggle');
        if (grainToggle) {
            grainToggle.addEventListener('change', (e) => {
                this.toggleGrain(e.target.checked);
            });
        }

        // Slider controls
        this.attachSliderListener('duplicateScale', 'duplicateScale');
        this.attachSliderListener('duplicateOpacity', 'duplicateOpacity');
        this.attachSliderListener('duplicateYOffset', 'duplicateYOffset');
        this.attachSliderListener('duplicateBlur', 'duplicateBlur');
        this.attachSliderListener('rotationX', 'maxTiltX');
        this.attachSliderListener('rotationY', 'maxTiltY');
        this.attachGrainSliderListener('grainScale', 'grainScale');
        this.attachGrainSliderListener('grainIntensity', 'grainIntensity');
        this.attachGrainSliderListener('grainBias', 'grainBias');
        this.attachGrainSliderListener('grainOpacity', 'grainOpacity');
    }
    
    attachSliderListener(controlName, settingName) {
        const control = document.getElementById(controlName);
        const display = document.getElementById(controlName + 'Value');
        
        if (!control || !display) return;
        
        control.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            display.textContent = value;
            this.settings[settingName] = value;
            
            if (!this.settings.motionEnabled) {
                this.resetToNeutral();
            }
        });
    }
    
    attachGrainSliderListener(controlName, settingName) {
        const control = document.getElementById(controlName);
        const display = document.getElementById(controlName + 'Value');
        
        if (!control || !display) {
            console.warn('Grain slider not found:', controlName);
            return;
        }
        
        console.log('Attached grain slider listener for:', controlName);
        
        control.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            console.log(`Grain slider ${controlName} changed to:`, value);
            
            display.textContent = value;
            this.settings[settingName] = value;
            
            console.log('Updated settings:', this.settings);
            
            if (this.grainRenderer && this.settings.grainEnabled) {
                console.log('Calling updateGrainSettings with:', this.settings);
                this.grainRenderer.updateGrainSettings(this.settings);
            } else {
                console.log('Grain renderer not available or grain disabled');
            }
        });
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.cardSystem = new SimpleCardSystem();
    
    // Debug helper functions
    window.debugGrain = (enabled) => {
        if (window.cardSystem && window.cardSystem.grainRenderer) {
            window.cardSystem.setGrainDebugMode(enabled);
        }
    };
    
    console.log('3D Card system initialized. Use debugGrain(true/false) to toggle debug mode.');
});
</script>
</body>
</html>